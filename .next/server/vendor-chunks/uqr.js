"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uqr";
exports.ids = ["vendor-chunks/uqr"];
exports.modules = {

/***/ "(ssr)/./node_modules/uqr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uqr/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QrCodeDataType: () => (/* binding */ QrCodeDataType),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   renderANSI: () => (/* binding */ renderANSI),\n/* harmony export */   renderSVG: () => (/* binding */ renderSVG),\n/* harmony export */   renderUnicode: () => (/* binding */ renderUnicode),\n/* harmony export */   renderUnicodeCompact: () => (/* binding */ renderUnicodeCompact)\n/* harmony export */ });\nvar QrCodeDataType = /* @__PURE__ */ ((QrCodeDataType2) => {\n  QrCodeDataType2[QrCodeDataType2[\"Border\"] = -1] = \"Border\";\n  QrCodeDataType2[QrCodeDataType2[\"Data\"] = 0] = \"Data\";\n  QrCodeDataType2[QrCodeDataType2[\"Function\"] = 1] = \"Function\";\n  QrCodeDataType2[QrCodeDataType2[\"Position\"] = 2] = \"Position\";\n  QrCodeDataType2[QrCodeDataType2[\"Timing\"] = 3] = \"Timing\";\n  QrCodeDataType2[QrCodeDataType2[\"Alignment\"] = 4] = \"Alignment\";\n  return QrCodeDataType2;\n})(QrCodeDataType || {});\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst LOW = [0, 1];\nconst MEDIUM = [1, 0];\nconst QUARTILE = [2, 3];\nconst HIGH = [3, 2];\nconst EccMap = {\n  L: LOW,\n  M: MEDIUM,\n  Q: QUARTILE,\n  H: HIGH\n};\nconst NUMERIC_REGEX = /^[0-9]*$/;\nconst ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\nconst ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\nconst MIN_VERSION = 1;\nconst MAX_VERSION = 40;\nconst PENALTY_N1 = 3;\nconst PENALTY_N2 = 3;\nconst PENALTY_N3 = 40;\nconst PENALTY_N4 = 10;\nconst ECC_CODEWORDS_PER_BLOCK = [\n  // Version: (note that index 0 is for padding, and is set to an illegal value)\n  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n  // Low\n  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n  // Medium\n  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n  // Quartile\n  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]\n  // High\n];\nconst NUM_ERROR_CORRECTION_BLOCKS = [\n  // Version: (note that index 0 is for padding, and is set to an illegal value)\n  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n  // Low\n  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n  // Medium\n  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n  // Quartile\n  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]\n  // High\n];\nclass QrCode {\n  /* -- Constructor (low level) and fields -- */\n  // Creates a new QR Code with the given version number,\n  // error correction level, data codeword bytes, and mask number.\n  // This is a low-level API that most users should not use directly.\n  // A mid-level API is the encodeSegments() function.\n  constructor(version, ecc, dataCodewords, msk) {\n    this.version = version;\n    this.ecc = ecc;\n    /* -- Fields -- */\n    // The width and height of this QR Code, measured in modules, between\n    // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n    __publicField(this, \"size\");\n    // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n    // Even if a QR Code is created with automatic masking requested (mask = -1),\n    // the resulting object still has a mask value between 0 and 7.\n    __publicField(this, \"mask\");\n    // The modules of this QR Code (false = light, true = dark).\n    // Immutable after constructor finishes. Accessed through getModule().\n    __publicField(this, \"modules\", []);\n    __publicField(this, \"types\", []);\n    if (version < MIN_VERSION || version > MAX_VERSION)\n      throw new RangeError(\"Version value out of range\");\n    if (msk < -1 || msk > 7)\n      throw new RangeError(\"Mask value out of range\");\n    this.size = version * 4 + 17;\n    const row = Array.from({ length: this.size }, () => false);\n    for (let i = 0; i < this.size; i++) {\n      this.modules.push(row.slice());\n      this.types.push(row.map(() => 0));\n    }\n    this.drawFunctionPatterns();\n    const allCodewords = this.addEccAndInterleave(dataCodewords);\n    this.drawCodewords(allCodewords);\n    if (msk === -1) {\n      let minPenalty = 1e9;\n      for (let i = 0; i < 8; i++) {\n        this.applyMask(i);\n        this.drawFormatBits(i);\n        const penalty = this.getPenaltyScore();\n        if (penalty < minPenalty) {\n          msk = i;\n          minPenalty = penalty;\n        }\n        this.applyMask(i);\n      }\n    }\n    this.mask = msk;\n    this.applyMask(msk);\n    this.drawFormatBits(msk);\n  }\n  /* -- Accessor methods -- */\n  // Returns the color of the module (pixel) at the given coordinates, which is false\n  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n  // If the given coordinates are out of bounds, then false (light) is returned.\n  getModule(x, y) {\n    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];\n  }\n  /* -- Private helper methods for constructor: Drawing function modules -- */\n  // Reads this object's version field, and draws and marks all function modules.\n  drawFunctionPatterns() {\n    for (let i = 0; i < this.size; i++) {\n      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);\n      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);\n    }\n    this.drawFinderPattern(3, 3);\n    this.drawFinderPattern(this.size - 4, 3);\n    this.drawFinderPattern(3, this.size - 4);\n    const alignPatPos = this.getAlignmentPatternPositions();\n    const numAlign = alignPatPos.length;\n    for (let i = 0; i < numAlign; i++) {\n      for (let j = 0; j < numAlign; j++) {\n        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))\n          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n      }\n    }\n    this.drawFormatBits(0);\n    this.drawVersion();\n  }\n  // Draws two copies of the format bits (with its own error correction code)\n  // based on the given mask and this object's error correction level field.\n  drawFormatBits(mask) {\n    const data = this.ecc[1] << 3 | mask;\n    let rem = data;\n    for (let i = 0; i < 10; i++)\n      rem = rem << 1 ^ (rem >>> 9) * 1335;\n    const bits = (data << 10 | rem) ^ 21522;\n    for (let i = 0; i <= 5; i++)\n      this.setFunctionModule(8, i, getBit(bits, i));\n    this.setFunctionModule(8, 7, getBit(bits, 6));\n    this.setFunctionModule(8, 8, getBit(bits, 7));\n    this.setFunctionModule(7, 8, getBit(bits, 8));\n    for (let i = 9; i < 15; i++)\n      this.setFunctionModule(14 - i, 8, getBit(bits, i));\n    for (let i = 0; i < 8; i++)\n      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n    for (let i = 8; i < 15; i++)\n      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n    this.setFunctionModule(8, this.size - 8, true);\n  }\n  // Draws two copies of the version bits (with its own error correction code),\n  // based on this object's version field, iff 7 <= version <= 40.\n  drawVersion() {\n    if (this.version < 7)\n      return;\n    let rem = this.version;\n    for (let i = 0; i < 12; i++)\n      rem = rem << 1 ^ (rem >>> 11) * 7973;\n    const bits = this.version << 12 | rem;\n    for (let i = 0; i < 18; i++) {\n      const color = getBit(bits, i);\n      const a = this.size - 11 + i % 3;\n      const b = Math.floor(i / 3);\n      this.setFunctionModule(a, b, color);\n      this.setFunctionModule(b, a, color);\n    }\n  }\n  // Draws a 9*9 finder pattern including the border separator,\n  // with the center module at (x, y). Modules can be out of bounds.\n  drawFinderPattern(x, y) {\n    for (let dy = -4; dy <= 4; dy++) {\n      for (let dx = -4; dx <= 4; dx++) {\n        const dist = Math.max(Math.abs(dx), Math.abs(dy));\n        const xx = x + dx;\n        const yy = y + dy;\n        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)\n          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);\n      }\n    }\n  }\n  // Draws a 5*5 alignment pattern, with the center module\n  // at (x, y). All modules must be in bounds.\n  drawAlignmentPattern(x, y) {\n    for (let dy = -2; dy <= 2; dy++) {\n      for (let dx = -2; dx <= 2; dx++) {\n        this.setFunctionModule(\n          x + dx,\n          y + dy,\n          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,\n          QrCodeDataType.Alignment\n        );\n      }\n    }\n  }\n  // Sets the color of a module and marks it as a function module.\n  // Only used by the constructor. Coordinates must be in bounds.\n  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {\n    this.modules[y][x] = isDark;\n    this.types[y][x] = type;\n  }\n  /* -- Private helper methods for constructor: Codewords and masking -- */\n  // Returns a new byte string representing the given data with the appropriate error correction\n  // codewords appended to it, based on this object's version and error correction level.\n  addEccAndInterleave(data) {\n    const ver = this.version;\n    const ecl = this.ecc;\n    if (data.length !== getNumDataCodewords(ver, ecl))\n      throw new RangeError(\"Invalid argument\");\n    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];\n    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];\n    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);\n    const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n    const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n    const blocks = [];\n    const rsDiv = reedSolomonComputeDivisor(blockEccLen);\n    for (let i = 0, k = 0; i < numBlocks; i++) {\n      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n      k += dat.length;\n      const ecc = reedSolomonComputeRemainder(dat, rsDiv);\n      if (i < numShortBlocks)\n        dat.push(0);\n      blocks.push(dat.concat(ecc));\n    }\n    const result = [];\n    for (let i = 0; i < blocks[0].length; i++) {\n      blocks.forEach((block, j) => {\n        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)\n          result.push(block[i]);\n      });\n    }\n    return result;\n  }\n  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n  // data area of this QR Code. Function modules need to be marked off before this is called.\n  drawCodewords(data) {\n    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))\n      throw new RangeError(\"Invalid argument\");\n    let i = 0;\n    for (let right = this.size - 1; right >= 1; right -= 2) {\n      if (right === 6)\n        right = 5;\n      for (let vert = 0; vert < this.size; vert++) {\n        for (let j = 0; j < 2; j++) {\n          const x = right - j;\n          const upward = (right + 1 & 2) === 0;\n          const y = upward ? this.size - 1 - vert : vert;\n          if (!this.types[y][x] && i < data.length * 8) {\n            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n            i++;\n          }\n        }\n      }\n    }\n  }\n  // XORs the codeword modules in this QR Code with the given mask pattern.\n  // The function modules must be marked and the codeword bits must be drawn\n  // before masking. Due to the arithmetic of XOR, calling applyMask() with\n  // the same mask value a second time will undo the mask. A final well-formed\n  // QR Code needs exactly one (not zero, two, etc.) mask applied.\n  applyMask(mask) {\n    if (mask < 0 || mask > 7)\n      throw new RangeError(\"Mask value out of range\");\n    for (let y = 0; y < this.size; y++) {\n      for (let x = 0; x < this.size; x++) {\n        let invert;\n        switch (mask) {\n          case 0:\n            invert = (x + y) % 2 === 0;\n            break;\n          case 1:\n            invert = y % 2 === 0;\n            break;\n          case 2:\n            invert = x % 3 === 0;\n            break;\n          case 3:\n            invert = (x + y) % 3 === 0;\n            break;\n          case 4:\n            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;\n            break;\n          case 5:\n            invert = x * y % 2 + x * y % 3 === 0;\n            break;\n          case 6:\n            invert = (x * y % 2 + x * y % 3) % 2 === 0;\n            break;\n          case 7:\n            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;\n            break;\n          default:\n            throw new Error(\"Unreachable\");\n        }\n        if (!this.types[y][x] && invert)\n          this.modules[y][x] = !this.modules[y][x];\n      }\n    }\n  }\n  // Calculates and returns the penalty score based on state of this QR Code's current modules.\n  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n  getPenaltyScore() {\n    let result = 0;\n    for (let y = 0; y < this.size; y++) {\n      let runColor = false;\n      let runX = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let x = 0; x < this.size; x++) {\n        if (this.modules[y][x] === runColor) {\n          runX++;\n          if (runX === 5)\n            result += PENALTY_N1;\n          else if (runX > 5)\n            result++;\n        } else {\n          this.finderPenaltyAddHistory(runX, runHistory);\n          if (!runColor)\n            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n          runColor = this.modules[y][x];\n          runX = 1;\n        }\n      }\n      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;\n    }\n    for (let x = 0; x < this.size; x++) {\n      let runColor = false;\n      let runY = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let y = 0; y < this.size; y++) {\n        if (this.modules[y][x] === runColor) {\n          runY++;\n          if (runY === 5)\n            result += PENALTY_N1;\n          else if (runY > 5)\n            result++;\n        } else {\n          this.finderPenaltyAddHistory(runY, runHistory);\n          if (!runColor)\n            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n          runColor = this.modules[y][x];\n          runY = 1;\n        }\n      }\n      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;\n    }\n    for (let y = 0; y < this.size - 1; y++) {\n      for (let x = 0; x < this.size - 1; x++) {\n        const color = this.modules[y][x];\n        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])\n          result += PENALTY_N2;\n      }\n    }\n    let dark = 0;\n    for (const row of this.modules)\n      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);\n    const total = this.size * this.size;\n    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n    result += k * PENALTY_N4;\n    return result;\n  }\n  /* -- Private helper functions -- */\n  // Returns an ascending list of positions of alignment patterns for this version number.\n  // Each position is in the range [0,177), and are used on both the x and y axes.\n  // This could be implemented as lookup table of 40 variable-length lists of integers.\n  getAlignmentPatternPositions() {\n    if (this.version === 1) {\n      return [];\n    } else {\n      const numAlign = Math.floor(this.version / 7) + 2;\n      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n      const result = [6];\n      for (let pos = this.size - 7; result.length < numAlign; pos -= step)\n        result.splice(1, 0, pos);\n      return result;\n    }\n  }\n  // Can only be called immediately after a light run is added, and\n  // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n  finderPenaltyCountPatterns(runHistory) {\n    const n = runHistory[1];\n    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;\n    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n  }\n  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n    if (currentRunColor) {\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      currentRunLength = 0;\n    }\n    currentRunLength += this.size;\n    this.finderPenaltyAddHistory(currentRunLength, runHistory);\n    return this.finderPenaltyCountPatterns(runHistory);\n  }\n  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n  finderPenaltyAddHistory(currentRunLength, runHistory) {\n    if (runHistory[0] === 0)\n      currentRunLength += this.size;\n    runHistory.pop();\n    runHistory.unshift(currentRunLength);\n  }\n}\nfunction appendBits(val, len, bb) {\n  if (len < 0 || len > 31 || val >>> len !== 0)\n    throw new RangeError(\"Value out of range\");\n  for (let i = len - 1; i >= 0; i--)\n    bb.push(val >>> i & 1);\n}\nfunction getBit(x, i) {\n  return (x >>> i & 1) !== 0;\n}\nclass QrSegment {\n  // Creates a new QR Code segment with the given attributes and data.\n  // The character count (numChars) must agree with the mode and the bit buffer length,\n  // but the constraint isn't checked. The given bit buffer is cloned and stored.\n  constructor(mode, numChars, bitData) {\n    this.mode = mode;\n    this.numChars = numChars;\n    this.bitData = bitData;\n    if (numChars < 0)\n      throw new RangeError(\"Invalid argument\");\n    this.bitData = bitData.slice();\n  }\n  /* -- Methods -- */\n  // Returns a new copy of the data bits of this segment.\n  getData() {\n    return this.bitData.slice();\n  }\n}\nconst MODE_NUMERIC = [1, 10, 12, 14];\nconst MODE_ALPHANUMERIC = [2, 9, 11, 13];\nconst MODE_BYTE = [4, 8, 16, 16];\nfunction numCharCountBits(mode, ver) {\n  return mode[Math.floor((ver + 7) / 17) + 1];\n}\nfunction makeBytes(data) {\n  const bb = [];\n  for (const b of data)\n    appendBits(b, 8, bb);\n  return new QrSegment(MODE_BYTE, data.length, bb);\n}\nfunction makeNumeric(digits) {\n  if (!isNumeric(digits))\n    throw new RangeError(\"String contains non-numeric characters\");\n  const bb = [];\n  for (let i = 0; i < digits.length; ) {\n    const n = Math.min(digits.length - i, 3);\n    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n    i += n;\n  }\n  return new QrSegment(MODE_NUMERIC, digits.length, bb);\n}\nfunction makeAlphanumeric(text) {\n  if (!isAlphanumeric(text))\n    throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n  const bb = [];\n  let i;\n  for (i = 0; i + 2 <= text.length; i += 2) {\n    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n    appendBits(temp, 11, bb);\n  }\n  if (i < text.length)\n    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);\n}\nfunction makeSegments(text) {\n  if (text === \"\")\n    return [];\n  else if (isNumeric(text))\n    return [makeNumeric(text)];\n  else if (isAlphanumeric(text))\n    return [makeAlphanumeric(text)];\n  else\n    return [makeBytes(toUtf8ByteArray(text))];\n}\nfunction isNumeric(text) {\n  return NUMERIC_REGEX.test(text);\n}\nfunction isAlphanumeric(text) {\n  return ALPHANUMERIC_REGEX.test(text);\n}\nfunction getTotalBits(segs, version) {\n  let result = 0;\n  for (const seg of segs) {\n    const ccbits = numCharCountBits(seg.mode, version);\n    if (seg.numChars >= 1 << ccbits)\n      return Number.POSITIVE_INFINITY;\n    result += 4 + ccbits + seg.bitData.length;\n  }\n  return result;\n}\nfunction toUtf8ByteArray(str) {\n  str = encodeURI(str);\n  const result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) !== \"%\") {\n      result.push(str.charCodeAt(i));\n    } else {\n      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));\n      i += 2;\n    }\n  }\n  return result;\n}\nfunction getNumRawDataModules(ver) {\n  if (ver < MIN_VERSION || ver > MAX_VERSION)\n    throw new RangeError(\"Version number out of range\");\n  let result = (16 * ver + 128) * ver + 64;\n  if (ver >= 2) {\n    const numAlign = Math.floor(ver / 7) + 2;\n    result -= (25 * numAlign - 10) * numAlign - 55;\n    if (ver >= 7)\n      result -= 36;\n  }\n  return result;\n}\nfunction getNumDataCodewords(ver, ecl) {\n  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];\n}\nfunction reedSolomonComputeDivisor(degree) {\n  if (degree < 1 || degree > 255)\n    throw new RangeError(\"Degree out of range\");\n  const result = [];\n  for (let i = 0; i < degree - 1; i++)\n    result.push(0);\n  result.push(1);\n  let root = 1;\n  for (let i = 0; i < degree; i++) {\n    for (let j = 0; j < result.length; j++) {\n      result[j] = reedSolomonMultiply(result[j], root);\n      if (j + 1 < result.length)\n        result[j] ^= result[j + 1];\n    }\n    root = reedSolomonMultiply(root, 2);\n  }\n  return result;\n}\nfunction reedSolomonComputeRemainder(data, divisor) {\n  const result = divisor.map((_) => 0);\n  for (const b of data) {\n    const factor = b ^ result.shift();\n    result.push(0);\n    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));\n  }\n  return result;\n}\nfunction reedSolomonMultiply(x, y) {\n  if (x >>> 8 !== 0 || y >>> 8 !== 0)\n    throw new RangeError(\"Byte out of range\");\n  let z = 0;\n  for (let i = 7; i >= 0; i--) {\n    z = z << 1 ^ (z >>> 7) * 285;\n    z ^= (y >>> i & 1) * x;\n  }\n  return z;\n}\nfunction encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)\n    throw new RangeError(\"Invalid value\");\n  let version;\n  let dataUsedBits;\n  for (version = minVersion; ; version++) {\n    const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;\n    const usedBits = getTotalBits(segs, version);\n    if (usedBits <= dataCapacityBits2) {\n      dataUsedBits = usedBits;\n      break;\n    }\n    if (version >= maxVersion)\n      throw new RangeError(\"Data too long\");\n  }\n  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {\n    if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)\n      ecl = newEcl;\n  }\n  const bb = [];\n  for (const seg of segs) {\n    appendBits(seg.mode[0], 4, bb);\n    appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);\n    for (const b of seg.getData())\n      bb.push(b);\n  }\n  const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n  appendBits(0, (8 - bb.length % 8) % 8, bb);\n  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)\n    appendBits(padByte, 8, bb);\n  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);\n  bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n  return new QrCode(version, ecl, dataCodewords, mask);\n}\n\nfunction encode(data, options) {\n  const {\n    ecc = \"L\",\n    boostEcc = false,\n    minVersion = 1,\n    maxVersion = 40,\n    maskPattern = -1,\n    border = 1\n  } = options || {};\n  const segment = typeof data === \"string\" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;\n  if (!segment)\n    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);\n  const qr = encodeSegments(\n    segment,\n    EccMap[ecc],\n    minVersion,\n    maxVersion,\n    maskPattern,\n    boostEcc\n  );\n  const result = addBorder({\n    version: qr.version,\n    maskPattern: qr.mask,\n    size: qr.size,\n    data: qr.modules,\n    types: qr.types\n  }, border);\n  if (options?.invert)\n    result.data = result.data.map((row) => row.map((mod) => !mod));\n  options?.onEncoded?.(result);\n  return result;\n}\nfunction addBorder(input, border = 1) {\n  if (!border)\n    return input;\n  const { size } = input;\n  const newSize = size + border * 2;\n  input.size = newSize;\n  input.data.forEach((row) => {\n    for (let i = 0; i < border; i++) {\n      row.unshift(false);\n      row.push(false);\n    }\n  });\n  for (let i = 0; i < border; i++) {\n    input.data.unshift(Array.from({ length: newSize }, (_) => false));\n    input.data.push(Array.from({ length: newSize }, (_) => false));\n  }\n  const b = QrCodeDataType.Border;\n  input.types.forEach((row) => {\n    for (let i = 0; i < border; i++) {\n      row.unshift(b);\n      row.push(b);\n    }\n  });\n  for (let i = 0; i < border; i++) {\n    input.types.unshift(Array.from({ length: newSize }, (_) => b));\n    input.types.push(Array.from({ length: newSize }, (_) => b));\n  }\n  return input;\n}\nfunction getDataAt(data, x, y, defaults = false) {\n  if (x < 0 || y < 0 || x >= data.length || y >= data.length)\n    return defaults;\n  return data[y][x];\n}\n\nfunction renderUnicode(data, options = {}) {\n  const {\n    whiteChar = \"\\u2588\",\n    blackChar = \"\\u2591\"\n  } = options;\n  const result = encode(data, options);\n  return result.data.map((row) => {\n    return row.map((mod) => mod ? blackChar : whiteChar).join(\"\");\n  }).join(\"\\n\");\n}\nfunction renderANSI(data, options = {}) {\n  return renderUnicode(data, {\n    ...options,\n    blackChar: \"\\x1B[40m\\u3000\\x1B[0m\",\n    whiteChar: \"\\x1B[47m\\u3000\\x1B[0m\"\n  });\n}\nfunction renderUnicodeCompact(data, options = {}) {\n  const platte = {\n    WHITE_ALL: \"\\u2588\",\n    WHITE_BLACK: \"\\u2580\",\n    BLACK_WHITE: \"\\u2584\",\n    BLACK_ALL: \" \"\n  };\n  const result = encode(data, options);\n  const WHITE = false;\n  const BLACK = true;\n  const at = (x, y) => getDataAt(result.data, x, y, true);\n  const lines = [];\n  let line = \"\";\n  for (let row = 0; row < result.size; row += 2) {\n    for (let col = 0; col < result.size; col++) {\n      if (at(col, row) === WHITE && at(col, row + 1) === WHITE)\n        line += platte.WHITE_ALL;\n      else if (at(col, row) === WHITE && at(col, row + 1) === BLACK)\n        line += platte.WHITE_BLACK;\n      else if (at(col, row) === BLACK && at(col, row + 1) === WHITE)\n        line += platte.BLACK_WHITE;\n      else\n        line += platte.BLACK_ALL;\n    }\n    lines.push(line);\n    line = \"\";\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction renderSVG(data, options = {}) {\n  const result = encode(data, options);\n  const {\n    pixelSize = 10,\n    whiteColor = \"white\",\n    blackColor = \"black\"\n  } = options;\n  const height = result.size * pixelSize;\n  const width = result.size * pixelSize;\n  let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\">`;\n  const pathes = [];\n  for (let row = 0; row < result.size; row++) {\n    for (let col = 0; col < result.size; col++) {\n      const x = col * pixelSize;\n      const y = row * pixelSize;\n      if (result.data[row][col])\n        pathes.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);\n    }\n  }\n  svg += `<rect fill=\"${whiteColor}\" width=\"${width}\" height=\"${height}\"/>`;\n  svg += `<path fill=\"${blackColor}\" d=\"${pathes.join(\"\")}\"/>`;\n  svg += \"</svg>\";\n  return svg;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXFyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRCxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0Isd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtRkFBbUYsWUFBWTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixZQUFZO0FBQzlCLG9DQUFvQyxpQkFBaUI7QUFDckQsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLFlBQVk7QUFDOUIscUNBQXFDLGlCQUFpQjtBQUN0RCxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9FQUFvRSxPQUFPLEVBQUUsT0FBTztBQUNwRjtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxHQUFHLEVBQUUsR0FBRyxVQUFVLEdBQUcsVUFBVSxJQUFJLFVBQVU7QUFDdkU7QUFDQTtBQUNBLHdCQUF3QixXQUFXLFdBQVcsTUFBTSxZQUFZLE9BQU87QUFDdkUsd0JBQXdCLFdBQVcsT0FBTyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBOztBQUU4RiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0eWxlclxcRGVza3RvcFxccmVzdW1lXFxyZXN1bWVcXG5vZGVfbW9kdWxlc1xcdXFyXFxkaXN0XFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFFyQ29kZURhdGFUeXBlID0gLyogQF9fUFVSRV9fICovICgoUXJDb2RlRGF0YVR5cGUyKSA9PiB7XG4gIFFyQ29kZURhdGFUeXBlMltRckNvZGVEYXRhVHlwZTJbXCJCb3JkZXJcIl0gPSAtMV0gPSBcIkJvcmRlclwiO1xuICBRckNvZGVEYXRhVHlwZTJbUXJDb2RlRGF0YVR5cGUyW1wiRGF0YVwiXSA9IDBdID0gXCJEYXRhXCI7XG4gIFFyQ29kZURhdGFUeXBlMltRckNvZGVEYXRhVHlwZTJbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICBRckNvZGVEYXRhVHlwZTJbUXJDb2RlRGF0YVR5cGUyW1wiUG9zaXRpb25cIl0gPSAyXSA9IFwiUG9zaXRpb25cIjtcbiAgUXJDb2RlRGF0YVR5cGUyW1FyQ29kZURhdGFUeXBlMltcIlRpbWluZ1wiXSA9IDNdID0gXCJUaW1pbmdcIjtcbiAgUXJDb2RlRGF0YVR5cGUyW1FyQ29kZURhdGFUeXBlMltcIkFsaWdubWVudFwiXSA9IDRdID0gXCJBbGlnbm1lbnRcIjtcbiAgcmV0dXJuIFFyQ29kZURhdGFUeXBlMjtcbn0pKFFyQ29kZURhdGFUeXBlIHx8IHt9KTtcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgTE9XID0gWzAsIDFdO1xuY29uc3QgTUVESVVNID0gWzEsIDBdO1xuY29uc3QgUVVBUlRJTEUgPSBbMiwgM107XG5jb25zdCBISUdIID0gWzMsIDJdO1xuY29uc3QgRWNjTWFwID0ge1xuICBMOiBMT1csXG4gIE06IE1FRElVTSxcbiAgUTogUVVBUlRJTEUsXG4gIEg6IEhJR0hcbn07XG5jb25zdCBOVU1FUklDX1JFR0VYID0gL15bMC05XSokLztcbmNvbnN0IEFMUEhBTlVNRVJJQ19SRUdFWCA9IC9eW0EtWjAtOSAkJSorLlxcLzotXSokLztcbmNvbnN0IEFMUEhBTlVNRVJJQ19DSEFSU0VUID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzpcIjtcbmNvbnN0IE1JTl9WRVJTSU9OID0gMTtcbmNvbnN0IE1BWF9WRVJTSU9OID0gNDA7XG5jb25zdCBQRU5BTFRZX04xID0gMztcbmNvbnN0IFBFTkFMVFlfTjIgPSAzO1xuY29uc3QgUEVOQUxUWV9OMyA9IDQwO1xuY29uc3QgUEVOQUxUWV9ONCA9IDEwO1xuY29uc3QgRUNDX0NPREVXT1JEU19QRVJfQkxPQ0sgPSBbXG4gIC8vIFZlcnNpb246IChub3RlIHRoYXQgaW5kZXggMCBpcyBmb3IgcGFkZGluZywgYW5kIGlzIHNldCB0byBhbiBpbGxlZ2FsIHZhbHVlKVxuICAvLyAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCAgICBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gIFstMSwgNywgMTAsIDE1LCAyMCwgMjYsIDE4LCAyMCwgMjQsIDMwLCAxOCwgMjAsIDI0LCAyNiwgMzAsIDIyLCAyNCwgMjgsIDMwLCAyOCwgMjgsIDI4LCAyOCwgMzAsIDMwLCAyNiwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gIC8vIExvd1xuICBbLTEsIDEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XSxcbiAgLy8gTWVkaXVtXG4gIFstMSwgMTMsIDIyLCAxOCwgMjYsIDE4LCAyNCwgMTgsIDIyLCAyMCwgMjQsIDI4LCAyNiwgMjQsIDIwLCAzMCwgMjQsIDI4LCAyOCwgMjYsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBdLFxuICAvLyBRdWFydGlsZVxuICBbLTEsIDE3LCAyOCwgMjIsIDE2LCAyMiwgMjgsIDI2LCAyNiwgMjQsIDI4LCAyNCwgMjgsIDIyLCAyNCwgMjQsIDMwLCAyOCwgMjgsIDI2LCAyOCwgMzAsIDI0LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXVxuICAvLyBIaWdoXG5dO1xuY29uc3QgTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTID0gW1xuICAvLyBWZXJzaW9uOiAobm90ZSB0aGF0IGluZGV4IDAgaXMgZm9yIHBhZGRpbmcsIGFuZCBpcyBzZXQgdG8gYW4gaWxsZWdhbCB2YWx1ZSlcbiAgLy8gMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCAgICBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gIFstMSwgMSwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgNCwgNCwgNCwgNCwgNCwgNiwgNiwgNiwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAxOSwgMjAsIDIxLCAyMiwgMjQsIDI1XSxcbiAgLy8gTG93XG4gIFstMSwgMSwgMSwgMSwgMiwgMiwgNCwgNCwgNCwgNSwgNSwgNSwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTMsIDE0LCAxNiwgMTcsIDE3LCAxOCwgMjAsIDIxLCAyMywgMjUsIDI2LCAyOCwgMjksIDMxLCAzMywgMzUsIDM3LCAzOCwgNDAsIDQzLCA0NSwgNDcsIDQ5XSxcbiAgLy8gTWVkaXVtXG4gIFstMSwgMSwgMSwgMiwgMiwgNCwgNCwgNiwgNiwgOCwgOCwgOCwgMTAsIDEyLCAxNiwgMTIsIDE3LCAxNiwgMTgsIDIxLCAyMCwgMjMsIDIzLCAyNSwgMjcsIDI5LCAzNCwgMzQsIDM1LCAzOCwgNDAsIDQzLCA0NSwgNDgsIDUxLCA1MywgNTYsIDU5LCA2MiwgNjUsIDY4XSxcbiAgLy8gUXVhcnRpbGVcbiAgWy0xLCAxLCAxLCAyLCA0LCA0LCA0LCA1LCA2LCA4LCA4LCAxMSwgMTEsIDE2LCAxNiwgMTgsIDE2LCAxOSwgMjEsIDI1LCAyNSwgMjUsIDM0LCAzMCwgMzIsIDM1LCAzNywgNDAsIDQyLCA0NSwgNDgsIDUxLCA1NCwgNTcsIDYwLCA2MywgNjYsIDcwLCA3NCwgNzcsIDgxXVxuICAvLyBIaWdoXG5dO1xuY2xhc3MgUXJDb2RlIHtcbiAgLyogLS0gQ29uc3RydWN0b3IgKGxvdyBsZXZlbCkgYW5kIGZpZWxkcyAtLSAqL1xuICAvLyBDcmVhdGVzIGEgbmV3IFFSIENvZGUgd2l0aCB0aGUgZ2l2ZW4gdmVyc2lvbiBudW1iZXIsXG4gIC8vIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwsIGRhdGEgY29kZXdvcmQgYnl0ZXMsIGFuZCBtYXNrIG51bWJlci5cbiAgLy8gVGhpcyBpcyBhIGxvdy1sZXZlbCBBUEkgdGhhdCBtb3N0IHVzZXJzIHNob3VsZCBub3QgdXNlIGRpcmVjdGx5LlxuICAvLyBBIG1pZC1sZXZlbCBBUEkgaXMgdGhlIGVuY29kZVNlZ21lbnRzKCkgZnVuY3Rpb24uXG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIGVjYywgZGF0YUNvZGV3b3JkcywgbXNrKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLmVjYyA9IGVjYztcbiAgICAvKiAtLSBGaWVsZHMgLS0gKi9cbiAgICAvLyBUaGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGlzIFFSIENvZGUsIG1lYXN1cmVkIGluIG1vZHVsZXMsIGJldHdlZW5cbiAgICAvLyAyMSBhbmQgMTc3IChpbmNsdXNpdmUpLiBUaGlzIGlzIGVxdWFsIHRvIHZlcnNpb24gKiA0ICsgMTcuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNpemVcIik7XG4gICAgLy8gVGhlIGluZGV4IG9mIHRoZSBtYXNrIHBhdHRlcm4gdXNlZCBpbiB0aGlzIFFSIENvZGUsIHdoaWNoIGlzIGJldHdlZW4gMCBhbmQgNyAoaW5jbHVzaXZlKS5cbiAgICAvLyBFdmVuIGlmIGEgUVIgQ29kZSBpcyBjcmVhdGVkIHdpdGggYXV0b21hdGljIG1hc2tpbmcgcmVxdWVzdGVkIChtYXNrID0gLTEpLFxuICAgIC8vIHRoZSByZXN1bHRpbmcgb2JqZWN0IHN0aWxsIGhhcyBhIG1hc2sgdmFsdWUgYmV0d2VlbiAwIGFuZCA3LlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXNrXCIpO1xuICAgIC8vIFRoZSBtb2R1bGVzIG9mIHRoaXMgUVIgQ29kZSAoZmFsc2UgPSBsaWdodCwgdHJ1ZSA9IGRhcmspLlxuICAgIC8vIEltbXV0YWJsZSBhZnRlciBjb25zdHJ1Y3RvciBmaW5pc2hlcy4gQWNjZXNzZWQgdGhyb3VnaCBnZXRNb2R1bGUoKS5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibW9kdWxlc1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInR5cGVzXCIsIFtdKTtcbiAgICBpZiAodmVyc2lvbiA8IE1JTl9WRVJTSU9OIHx8IHZlcnNpb24gPiBNQVhfVkVSU0lPTilcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmVyc2lvbiB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgaWYgKG1zayA8IC0xIHx8IG1zayA+IDcpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgIHRoaXMuc2l6ZSA9IHZlcnNpb24gKiA0ICsgMTc7XG4gICAgY29uc3Qgcm93ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5zaXplIH0sICgpID0+IGZhbHNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLm1vZHVsZXMucHVzaChyb3cuc2xpY2UoKSk7XG4gICAgICB0aGlzLnR5cGVzLnB1c2gocm93Lm1hcCgoKSA9PiAwKSk7XG4gICAgfVxuICAgIHRoaXMuZHJhd0Z1bmN0aW9uUGF0dGVybnMoKTtcbiAgICBjb25zdCBhbGxDb2Rld29yZHMgPSB0aGlzLmFkZEVjY0FuZEludGVybGVhdmUoZGF0YUNvZGV3b3Jkcyk7XG4gICAgdGhpcy5kcmF3Q29kZXdvcmRzKGFsbENvZGV3b3Jkcyk7XG4gICAgaWYgKG1zayA9PT0gLTEpIHtcbiAgICAgIGxldCBtaW5QZW5hbHR5ID0gMWU5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoaSk7XG4gICAgICAgIGNvbnN0IHBlbmFsdHkgPSB0aGlzLmdldFBlbmFsdHlTY29yZSgpO1xuICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICBtc2sgPSBpO1xuICAgICAgICAgIG1pblBlbmFsdHkgPSBwZW5hbHR5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hc2sgPSBtc2s7XG4gICAgdGhpcy5hcHBseU1hc2sobXNrKTtcbiAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKG1zayk7XG4gIH1cbiAgLyogLS0gQWNjZXNzb3IgbWV0aG9kcyAtLSAqL1xuICAvLyBSZXR1cm5zIHRoZSBjb2xvciBvZiB0aGUgbW9kdWxlIChwaXhlbCkgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCB3aGljaCBpcyBmYWxzZVxuICAvLyBmb3IgbGlnaHQgb3IgdHJ1ZSBmb3IgZGFyay4gVGhlIHRvcCBsZWZ0IGNvcm5lciBoYXMgdGhlIGNvb3JkaW5hdGVzICh4PTAsIHk9MCkuXG4gIC8vIElmIHRoZSBnaXZlbiBjb29yZGluYXRlcyBhcmUgb3V0IG9mIGJvdW5kcywgdGhlbiBmYWxzZSAobGlnaHQpIGlzIHJldHVybmVkLlxuICBnZXRNb2R1bGUoeCwgeSkge1xuICAgIHJldHVybiB4ID49IDAgJiYgeCA8IHRoaXMuc2l6ZSAmJiB5ID49IDAgJiYgeSA8IHRoaXMuc2l6ZSAmJiB0aGlzLm1vZHVsZXNbeV1beF07XG4gIH1cbiAgLyogLS0gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kcyBmb3IgY29uc3RydWN0b3I6IERyYXdpbmcgZnVuY3Rpb24gbW9kdWxlcyAtLSAqL1xuICAvLyBSZWFkcyB0aGlzIG9iamVjdCdzIHZlcnNpb24gZmllbGQsIGFuZCBkcmF3cyBhbmQgbWFya3MgYWxsIGZ1bmN0aW9uIG1vZHVsZXMuXG4gIGRyYXdGdW5jdGlvblBhdHRlcm5zKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNiwgaSwgaSAlIDIgPT09IDAsIFFyQ29kZURhdGFUeXBlLlRpbWluZyk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGksIDYsIGkgJSAyID09PSAwLCBRckNvZGVEYXRhVHlwZS5UaW1pbmcpO1xuICAgIH1cbiAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKDMsIDMpO1xuICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4odGhpcy5zaXplIC0gNCwgMyk7XG4gICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCB0aGlzLnNpemUgLSA0KTtcbiAgICBjb25zdCBhbGlnblBhdFBvcyA9IHRoaXMuZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpO1xuICAgIGNvbnN0IG51bUFsaWduID0gYWxpZ25QYXRQb3MubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQWxpZ247IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1BbGlnbjsgaisrKSB7XG4gICAgICAgIGlmICghKGkgPT09IDAgJiYgaiA9PT0gMCB8fCBpID09PSAwICYmIGogPT09IG51bUFsaWduIC0gMSB8fCBpID09PSBudW1BbGlnbiAtIDEgJiYgaiA9PT0gMCkpXG4gICAgICAgICAgdGhpcy5kcmF3QWxpZ25tZW50UGF0dGVybihhbGlnblBhdFBvc1tpXSwgYWxpZ25QYXRQb3Nbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKDApO1xuICAgIHRoaXMuZHJhd1ZlcnNpb24oKTtcbiAgfVxuICAvLyBEcmF3cyB0d28gY29waWVzIG9mIHRoZSBmb3JtYXQgYml0cyAod2l0aCBpdHMgb3duIGVycm9yIGNvcnJlY3Rpb24gY29kZSlcbiAgLy8gYmFzZWQgb24gdGhlIGdpdmVuIG1hc2sgYW5kIHRoaXMgb2JqZWN0J3MgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBmaWVsZC5cbiAgZHJhd0Zvcm1hdEJpdHMobWFzaykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmVjY1sxXSA8PCAzIHwgbWFzaztcbiAgICBsZXQgcmVtID0gZGF0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICByZW0gPSByZW0gPDwgMSBeIChyZW0gPj4+IDkpICogMTMzNTtcbiAgICBjb25zdCBiaXRzID0gKGRhdGEgPDwgMTAgfCByZW0pIF4gMjE1MjI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNTsgaSsrKVxuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCBpLCBnZXRCaXQoYml0cywgaSkpO1xuICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgNywgZ2V0Qml0KGJpdHMsIDYpKTtcbiAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDgsIGdldEJpdChiaXRzLCA3KSk7XG4gICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg3LCA4LCBnZXRCaXQoYml0cywgOCkpO1xuICAgIGZvciAobGV0IGkgPSA5OyBpIDwgMTU7IGkrKylcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoMTQgLSBpLCA4LCBnZXRCaXQoYml0cywgaSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh0aGlzLnNpemUgLSAxIC0gaSwgOCwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIHRoaXMuc2l6ZSAtIDE1ICsgaSwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIHRoaXMuc2l6ZSAtIDgsIHRydWUpO1xuICB9XG4gIC8vIERyYXdzIHR3byBjb3BpZXMgb2YgdGhlIHZlcnNpb24gYml0cyAod2l0aCBpdHMgb3duIGVycm9yIGNvcnJlY3Rpb24gY29kZSksXG4gIC8vIGJhc2VkIG9uIHRoaXMgb2JqZWN0J3MgdmVyc2lvbiBmaWVsZCwgaWZmIDcgPD0gdmVyc2lvbiA8PSA0MC5cbiAgZHJhd1ZlcnNpb24oKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA8IDcpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHJlbSA9IHRoaXMudmVyc2lvbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspXG4gICAgICByZW0gPSByZW0gPDwgMSBeIChyZW0gPj4+IDExKSAqIDc5NzM7XG4gICAgY29uc3QgYml0cyA9IHRoaXMudmVyc2lvbiA8PCAxMiB8IHJlbTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE4OyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Qml0KGJpdHMsIGkpO1xuICAgICAgY29uc3QgYSA9IHRoaXMuc2l6ZSAtIDExICsgaSAlIDM7XG4gICAgICBjb25zdCBiID0gTWF0aC5mbG9vcihpIC8gMyk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGEsIGIsIGNvbG9yKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoYiwgYSwgY29sb3IpO1xuICAgIH1cbiAgfVxuICAvLyBEcmF3cyBhIDkqOSBmaW5kZXIgcGF0dGVybiBpbmNsdWRpbmcgdGhlIGJvcmRlciBzZXBhcmF0b3IsXG4gIC8vIHdpdGggdGhlIGNlbnRlciBtb2R1bGUgYXQgKHgsIHkpLiBNb2R1bGVzIGNhbiBiZSBvdXQgb2YgYm91bmRzLlxuICBkcmF3RmluZGVyUGF0dGVybih4LCB5KSB7XG4gICAgZm9yIChsZXQgZHkgPSAtNDsgZHkgPD0gNDsgZHkrKykge1xuICAgICAgZm9yIChsZXQgZHggPSAtNDsgZHggPD0gNDsgZHgrKykge1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpO1xuICAgICAgICBjb25zdCB4eCA9IHggKyBkeDtcbiAgICAgICAgY29uc3QgeXkgPSB5ICsgZHk7XG4gICAgICAgIGlmICh4eCA+PSAwICYmIHh4IDwgdGhpcy5zaXplICYmIHl5ID49IDAgJiYgeXkgPCB0aGlzLnNpemUpXG4gICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4eCwgeXksIGRpc3QgIT09IDIgJiYgZGlzdCAhPT0gNCwgUXJDb2RlRGF0YVR5cGUuUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEcmF3cyBhIDUqNSBhbGlnbm1lbnQgcGF0dGVybiwgd2l0aCB0aGUgY2VudGVyIG1vZHVsZVxuICAvLyBhdCAoeCwgeSkuIEFsbCBtb2R1bGVzIG11c3QgYmUgaW4gYm91bmRzLlxuICBkcmF3QWxpZ25tZW50UGF0dGVybih4LCB5KSB7XG4gICAgZm9yIChsZXQgZHkgPSAtMjsgZHkgPD0gMjsgZHkrKykge1xuICAgICAgZm9yIChsZXQgZHggPSAtMjsgZHggPD0gMjsgZHgrKykge1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKFxuICAgICAgICAgIHggKyBkeCxcbiAgICAgICAgICB5ICsgZHksXG4gICAgICAgICAgTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpICE9PSAxLFxuICAgICAgICAgIFFyQ29kZURhdGFUeXBlLkFsaWdubWVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBTZXRzIHRoZSBjb2xvciBvZiBhIG1vZHVsZSBhbmQgbWFya3MgaXQgYXMgYSBmdW5jdGlvbiBtb2R1bGUuXG4gIC8vIE9ubHkgdXNlZCBieSB0aGUgY29uc3RydWN0b3IuIENvb3JkaW5hdGVzIG11c3QgYmUgaW4gYm91bmRzLlxuICBzZXRGdW5jdGlvbk1vZHVsZSh4LCB5LCBpc0RhcmssIHR5cGUgPSBRckNvZGVEYXRhVHlwZS5GdW5jdGlvbikge1xuICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9IGlzRGFyaztcbiAgICB0aGlzLnR5cGVzW3ldW3hdID0gdHlwZTtcbiAgfVxuICAvKiAtLSBQcml2YXRlIGhlbHBlciBtZXRob2RzIGZvciBjb25zdHJ1Y3RvcjogQ29kZXdvcmRzIGFuZCBtYXNraW5nIC0tICovXG4gIC8vIFJldHVybnMgYSBuZXcgYnl0ZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhlIGFwcHJvcHJpYXRlIGVycm9yIGNvcnJlY3Rpb25cbiAgLy8gY29kZXdvcmRzIGFwcGVuZGVkIHRvIGl0LCBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIHZlcnNpb24gYW5kIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuXG4gIGFkZEVjY0FuZEludGVybGVhdmUoZGF0YSkge1xuICAgIGNvbnN0IHZlciA9IHRoaXMudmVyc2lvbjtcbiAgICBjb25zdCBlY2wgPSB0aGlzLmVjYztcbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IGdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgIGNvbnN0IG51bUJsb2NrcyA9IE5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLU1tlY2xbMF1dW3Zlcl07XG4gICAgY29uc3QgYmxvY2tFY2NMZW4gPSBFQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2xbMF1dW3Zlcl07XG4gICAgY29uc3QgcmF3Q29kZXdvcmRzID0gTWF0aC5mbG9vcihnZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCk7XG4gICAgY29uc3QgbnVtU2hvcnRCbG9ja3MgPSBudW1CbG9ja3MgLSByYXdDb2Rld29yZHMgJSBudW1CbG9ja3M7XG4gICAgY29uc3Qgc2hvcnRCbG9ja0xlbiA9IE1hdGguZmxvb3IocmF3Q29kZXdvcmRzIC8gbnVtQmxvY2tzKTtcbiAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICBjb25zdCByc0RpdiA9IHJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoYmxvY2tFY2NMZW4pO1xuICAgIGZvciAobGV0IGkgPSAwLCBrID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICBjb25zdCBkYXQgPSBkYXRhLnNsaWNlKGssIGsgKyBzaG9ydEJsb2NrTGVuIC0gYmxvY2tFY2NMZW4gKyAoaSA8IG51bVNob3J0QmxvY2tzID8gMCA6IDEpKTtcbiAgICAgIGsgKz0gZGF0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVjYyA9IHJlZWRTb2xvbW9uQ29tcHV0ZVJlbWFpbmRlcihkYXQsIHJzRGl2KTtcbiAgICAgIGlmIChpIDwgbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgIGRhdC5wdXNoKDApO1xuICAgICAgYmxvY2tzLnB1c2goZGF0LmNvbmNhdChlY2MpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJsb2Nrcy5mb3JFYWNoKChibG9jaywgaikgPT4ge1xuICAgICAgICBpZiAoaSAhPT0gc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuIHx8IGogPj0gbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgcmVzdWx0LnB1c2goYmxvY2tbaV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gRHJhd3MgdGhlIGdpdmVuIHNlcXVlbmNlIG9mIDgtYml0IGNvZGV3b3JkcyAoZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbikgb250byB0aGUgZW50aXJlXG4gIC8vIGRhdGEgYXJlYSBvZiB0aGlzIFFSIENvZGUuIEZ1bmN0aW9uIG1vZHVsZXMgbmVlZCB0byBiZSBtYXJrZWQgb2ZmIGJlZm9yZSB0aGlzIGlzIGNhbGxlZC5cbiAgZHJhd0NvZGV3b3JkcyhkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSBNYXRoLmZsb29yKGdldE51bVJhd0RhdGFNb2R1bGVzKHRoaXMudmVyc2lvbikgLyA4KSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgcmlnaHQgPSB0aGlzLnNpemUgLSAxOyByaWdodCA+PSAxOyByaWdodCAtPSAyKSB7XG4gICAgICBpZiAocmlnaHQgPT09IDYpXG4gICAgICAgIHJpZ2h0ID0gNTtcbiAgICAgIGZvciAobGV0IHZlcnQgPSAwOyB2ZXJ0IDwgdGhpcy5zaXplOyB2ZXJ0KyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB4ID0gcmlnaHQgLSBqO1xuICAgICAgICAgIGNvbnN0IHVwd2FyZCA9IChyaWdodCArIDEgJiAyKSA9PT0gMDtcbiAgICAgICAgICBjb25zdCB5ID0gdXB3YXJkID8gdGhpcy5zaXplIC0gMSAtIHZlcnQgOiB2ZXJ0O1xuICAgICAgICAgIGlmICghdGhpcy50eXBlc1t5XVt4XSAmJiBpIDwgZGF0YS5sZW5ndGggKiA4KSB7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBnZXRCaXQoZGF0YVtpID4+PiAzXSwgNyAtIChpICYgNykpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBYT1JzIHRoZSBjb2Rld29yZCBtb2R1bGVzIGluIHRoaXMgUVIgQ29kZSB3aXRoIHRoZSBnaXZlbiBtYXNrIHBhdHRlcm4uXG4gIC8vIFRoZSBmdW5jdGlvbiBtb2R1bGVzIG11c3QgYmUgbWFya2VkIGFuZCB0aGUgY29kZXdvcmQgYml0cyBtdXN0IGJlIGRyYXduXG4gIC8vIGJlZm9yZSBtYXNraW5nLiBEdWUgdG8gdGhlIGFyaXRobWV0aWMgb2YgWE9SLCBjYWxsaW5nIGFwcGx5TWFzaygpIHdpdGhcbiAgLy8gdGhlIHNhbWUgbWFzayB2YWx1ZSBhIHNlY29uZCB0aW1lIHdpbGwgdW5kbyB0aGUgbWFzay4gQSBmaW5hbCB3ZWxsLWZvcm1lZFxuICAvLyBRUiBDb2RlIG5lZWRzIGV4YWN0bHkgb25lIChub3QgemVybywgdHdvLCBldGMuKSBtYXNrIGFwcGxpZWQuXG4gIGFwcGx5TWFzayhtYXNrKSB7XG4gICAgaWYgKG1hc2sgPCAwIHx8IG1hc2sgPiA3KVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXNrIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGxldCBpbnZlcnQ7XG4gICAgICAgIHN3aXRjaCAobWFzaykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGludmVydCA9ICh4ICsgeSkgJSAyID09PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaW52ZXJ0ID0geSAlIDIgPT09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpbnZlcnQgPSB4ICUgMyA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGludmVydCA9ICh4ICsgeSkgJSAzID09PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaW52ZXJ0ID0gKE1hdGguZmxvb3IoeCAvIDMpICsgTWF0aC5mbG9vcih5IC8gMikpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGludmVydCA9IHggKiB5ICUgMiArIHggKiB5ICUgMyA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGludmVydCA9ICh4ICogeSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGludmVydCA9ICgoeCArIHkpICUgMiArIHggKiB5ICUgMykgJSAyID09PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50eXBlc1t5XVt4XSAmJiBpbnZlcnQpXG4gICAgICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gIXRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcGVuYWx0eSBzY29yZSBiYXNlZCBvbiBzdGF0ZSBvZiB0aGlzIFFSIENvZGUncyBjdXJyZW50IG1vZHVsZXMuXG4gIC8vIFRoaXMgaXMgdXNlZCBieSB0aGUgYXV0b21hdGljIG1hc2sgY2hvaWNlIGFsZ29yaXRobSB0byBmaW5kIHRoZSBtYXNrIHBhdHRlcm4gdGhhdCB5aWVsZHMgdGhlIGxvd2VzdCBzY29yZS5cbiAgZ2V0UGVuYWx0eVNjb3JlKCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplOyB5KyspIHtcbiAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgbGV0IHJ1blggPSAwO1xuICAgICAgY29uc3QgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplOyB4KyspIHtcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICBydW5YKys7XG4gICAgICAgICAgaWYgKHJ1blggPT09IDUpXG4gICAgICAgICAgICByZXN1bHQgKz0gUEVOQUxUWV9OMTtcbiAgICAgICAgICBlbHNlIGlmIChydW5YID4gNSlcbiAgICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWCwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgaWYgKCFydW5Db2xvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogUEVOQUxUWV9OMztcbiAgICAgICAgICBydW5Db2xvciA9IHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgICBydW5YID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KHJ1bkNvbG9yLCBydW5YLCBydW5IaXN0b3J5KSAqIFBFTkFMVFlfTjM7XG4gICAgfVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplOyB4KyspIHtcbiAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgbGV0IHJ1blkgPSAwO1xuICAgICAgY29uc3QgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplOyB5KyspIHtcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICBydW5ZKys7XG4gICAgICAgICAgaWYgKHJ1blkgPT09IDUpXG4gICAgICAgICAgICByZXN1bHQgKz0gUEVOQUxUWV9OMTtcbiAgICAgICAgICBlbHNlIGlmIChydW5ZID4gNSlcbiAgICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWSwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgaWYgKCFydW5Db2xvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogUEVOQUxUWV9OMztcbiAgICAgICAgICBydW5Db2xvciA9IHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgICBydW5ZID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KHJ1bkNvbG9yLCBydW5ZLCBydW5IaXN0b3J5KSAqIFBFTkFMVFlfTjM7XG4gICAgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplIC0gMTsgeSsrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZSAtIDE7IHgrKykge1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgaWYgKGNvbG9yID09PSB0aGlzLm1vZHVsZXNbeV1beCArIDFdICYmIGNvbG9yID09PSB0aGlzLm1vZHVsZXNbeSArIDFdW3hdICYmIGNvbG9yID09PSB0aGlzLm1vZHVsZXNbeSArIDFdW3ggKyAxXSlcbiAgICAgICAgICByZXN1bHQgKz0gUEVOQUxUWV9OMjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhcmsgPSAwO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMubW9kdWxlcylcbiAgICAgIGRhcmsgPSByb3cucmVkdWNlKChzdW0sIGNvbG9yKSA9PiBzdW0gKyAoY29sb3IgPyAxIDogMCksIGRhcmspO1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5zaXplICogdGhpcy5zaXplO1xuICAgIGNvbnN0IGsgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGFyayAqIDIwIC0gdG90YWwgKiAxMCkgLyB0b3RhbCkgLSAxO1xuICAgIHJlc3VsdCArPSBrICogUEVOQUxUWV9ONDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qIC0tIFByaXZhdGUgaGVscGVyIGZ1bmN0aW9ucyAtLSAqL1xuICAvLyBSZXR1cm5zIGFuIGFzY2VuZGluZyBsaXN0IG9mIHBvc2l0aW9ucyBvZiBhbGlnbm1lbnQgcGF0dGVybnMgZm9yIHRoaXMgdmVyc2lvbiBudW1iZXIuXG4gIC8vIEVhY2ggcG9zaXRpb24gaXMgaW4gdGhlIHJhbmdlIFswLDE3NyksIGFuZCBhcmUgdXNlZCBvbiBib3RoIHRoZSB4IGFuZCB5IGF4ZXMuXG4gIC8vIFRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgbG9va3VwIHRhYmxlIG9mIDQwIHZhcmlhYmxlLWxlbmd0aCBsaXN0cyBvZiBpbnRlZ2Vycy5cbiAgZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih0aGlzLnZlcnNpb24gLyA3KSArIDI7XG4gICAgICBjb25zdCBzdGVwID0gdGhpcy52ZXJzaW9uID09PSAzMiA/IDI2IDogTWF0aC5jZWlsKCh0aGlzLnZlcnNpb24gKiA0ICsgNCkgLyAobnVtQWxpZ24gKiAyIC0gMikpICogMjtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFs2XTtcbiAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuc2l6ZSAtIDc7IHJlc3VsdC5sZW5ndGggPCBudW1BbGlnbjsgcG9zIC09IHN0ZXApXG4gICAgICAgIHJlc3VsdC5zcGxpY2UoMSwgMCwgcG9zKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIC8vIENhbiBvbmx5IGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIGxpZ2h0IHJ1biBpcyBhZGRlZCwgYW5kXG4gIC8vIHJldHVybnMgZWl0aGVyIDAsIDEsIG9yIDIuIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXRQZW5hbHR5U2NvcmUoKS5cbiAgZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkge1xuICAgIGNvbnN0IG4gPSBydW5IaXN0b3J5WzFdO1xuICAgIGNvbnN0IGNvcmUgPSBuID4gMCAmJiBydW5IaXN0b3J5WzJdID09PSBuICYmIHJ1bkhpc3RvcnlbM10gPT09IG4gKiAzICYmIHJ1bkhpc3RvcnlbNF0gPT09IG4gJiYgcnVuSGlzdG9yeVs1XSA9PT0gbjtcbiAgICByZXR1cm4gKGNvcmUgJiYgcnVuSGlzdG9yeVswXSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzZdID49IG4gPyAxIDogMCkgKyAoY29yZSAmJiBydW5IaXN0b3J5WzZdID49IG4gKiA0ICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiA/IDEgOiAwKTtcbiAgfVxuICAvLyBNdXN0IGJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGEgbGluZSAocm93IG9yIGNvbHVtbikgb2YgbW9kdWxlcy4gQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldFBlbmFsdHlTY29yZSgpLlxuICBmaW5kZXJQZW5hbHR5VGVybWluYXRlQW5kQ291bnQoY3VycmVudFJ1bkNvbG9yLCBjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KSB7XG4gICAgaWYgKGN1cnJlbnRSdW5Db2xvcikge1xuICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgIGN1cnJlbnRSdW5MZW5ndGggPSAwO1xuICAgIH1cbiAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpO1xuICAgIHJldHVybiB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpO1xuICB9XG4gIC8vIFB1c2hlcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGZyb250IGFuZCBkcm9wcyB0aGUgbGFzdCB2YWx1ZS4gQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldFBlbmFsdHlTY29yZSgpLlxuICBmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KSB7XG4gICAgaWYgKHJ1bkhpc3RvcnlbMF0gPT09IDApXG4gICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICBydW5IaXN0b3J5LnBvcCgpO1xuICAgIHJ1bkhpc3RvcnkudW5zaGlmdChjdXJyZW50UnVuTGVuZ3RoKTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kQml0cyh2YWwsIGxlbiwgYmIpIHtcbiAgaWYgKGxlbiA8IDAgfHwgbGVuID4gMzEgfHwgdmFsID4+PiBsZW4gIT09IDApXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSlcbiAgICBiYi5wdXNoKHZhbCA+Pj4gaSAmIDEpO1xufVxuZnVuY3Rpb24gZ2V0Qml0KHgsIGkpIHtcbiAgcmV0dXJuICh4ID4+PiBpICYgMSkgIT09IDA7XG59XG5jbGFzcyBRclNlZ21lbnQge1xuICAvLyBDcmVhdGVzIGEgbmV3IFFSIENvZGUgc2VnbWVudCB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFuZCBkYXRhLlxuICAvLyBUaGUgY2hhcmFjdGVyIGNvdW50IChudW1DaGFycykgbXVzdCBhZ3JlZSB3aXRoIHRoZSBtb2RlIGFuZCB0aGUgYml0IGJ1ZmZlciBsZW5ndGgsXG4gIC8vIGJ1dCB0aGUgY29uc3RyYWludCBpc24ndCBjaGVja2VkLiBUaGUgZ2l2ZW4gYml0IGJ1ZmZlciBpcyBjbG9uZWQgYW5kIHN0b3JlZC5cbiAgY29uc3RydWN0b3IobW9kZSwgbnVtQ2hhcnMsIGJpdERhdGEpIHtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMubnVtQ2hhcnMgPSBudW1DaGFycztcbiAgICB0aGlzLmJpdERhdGEgPSBiaXREYXRhO1xuICAgIGlmIChudW1DaGFycyA8IDApXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gICAgdGhpcy5iaXREYXRhID0gYml0RGF0YS5zbGljZSgpO1xuICB9XG4gIC8qIC0tIE1ldGhvZHMgLS0gKi9cbiAgLy8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIHRoZSBkYXRhIGJpdHMgb2YgdGhpcyBzZWdtZW50LlxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmJpdERhdGEuc2xpY2UoKTtcbiAgfVxufVxuY29uc3QgTU9ERV9OVU1FUklDID0gWzEsIDEwLCAxMiwgMTRdO1xuY29uc3QgTU9ERV9BTFBIQU5VTUVSSUMgPSBbMiwgOSwgMTEsIDEzXTtcbmNvbnN0IE1PREVfQllURSA9IFs0LCA4LCAxNiwgMTZdO1xuZnVuY3Rpb24gbnVtQ2hhckNvdW50Qml0cyhtb2RlLCB2ZXIpIHtcbiAgcmV0dXJuIG1vZGVbTWF0aC5mbG9vcigodmVyICsgNykgLyAxNykgKyAxXTtcbn1cbmZ1bmN0aW9uIG1ha2VCeXRlcyhkYXRhKSB7XG4gIGNvbnN0IGJiID0gW107XG4gIGZvciAoY29uc3QgYiBvZiBkYXRhKVxuICAgIGFwcGVuZEJpdHMoYiwgOCwgYmIpO1xuICByZXR1cm4gbmV3IFFyU2VnbWVudChNT0RFX0JZVEUsIGRhdGEubGVuZ3RoLCBiYik7XG59XG5mdW5jdGlvbiBtYWtlTnVtZXJpYyhkaWdpdHMpIHtcbiAgaWYgKCFpc051bWVyaWMoZGlnaXRzKSlcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN0cmluZyBjb250YWlucyBub24tbnVtZXJpYyBjaGFyYWN0ZXJzXCIpO1xuICBjb25zdCBiYiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG4gPSBNYXRoLm1pbihkaWdpdHMubGVuZ3RoIC0gaSwgMyk7XG4gICAgYXBwZW5kQml0cyhOdW1iZXIucGFyc2VJbnQoZGlnaXRzLnN1YnN0cmluZyhpLCBpICsgbiksIDEwKSwgbiAqIDMgKyAxLCBiYik7XG4gICAgaSArPSBuO1xuICB9XG4gIHJldHVybiBuZXcgUXJTZWdtZW50KE1PREVfTlVNRVJJQywgZGlnaXRzLmxlbmd0aCwgYmIpO1xufVxuZnVuY3Rpb24gbWFrZUFscGhhbnVtZXJpYyh0ZXh0KSB7XG4gIGlmICghaXNBbHBoYW51bWVyaWModGV4dCkpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdHJpbmcgY29udGFpbnMgdW5lbmNvZGFibGUgY2hhcmFjdGVycyBpbiBhbHBoYW51bWVyaWMgbW9kZVwiKTtcbiAgY29uc3QgYmIgPSBbXTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDA7IGkgKyAyIDw9IHRleHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBsZXQgdGVtcCA9IEFMUEhBTlVNRVJJQ19DSEFSU0VULmluZGV4T2YodGV4dC5jaGFyQXQoaSkpICogNDU7XG4gICAgdGVtcCArPSBBTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkgKyAxKSk7XG4gICAgYXBwZW5kQml0cyh0ZW1wLCAxMSwgYmIpO1xuICB9XG4gIGlmIChpIDwgdGV4dC5sZW5ndGgpXG4gICAgYXBwZW5kQml0cyhBTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSwgNiwgYmIpO1xuICByZXR1cm4gbmV3IFFyU2VnbWVudChNT0RFX0FMUEhBTlVNRVJJQywgdGV4dC5sZW5ndGgsIGJiKTtcbn1cbmZ1bmN0aW9uIG1ha2VTZWdtZW50cyh0ZXh0KSB7XG4gIGlmICh0ZXh0ID09PSBcIlwiKVxuICAgIHJldHVybiBbXTtcbiAgZWxzZSBpZiAoaXNOdW1lcmljKHRleHQpKVxuICAgIHJldHVybiBbbWFrZU51bWVyaWModGV4dCldO1xuICBlbHNlIGlmIChpc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICByZXR1cm4gW21ha2VBbHBoYW51bWVyaWModGV4dCldO1xuICBlbHNlXG4gICAgcmV0dXJuIFttYWtlQnl0ZXModG9VdGY4Qnl0ZUFycmF5KHRleHQpKV07XG59XG5mdW5jdGlvbiBpc051bWVyaWModGV4dCkge1xuICByZXR1cm4gTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xufVxuZnVuY3Rpb24gaXNBbHBoYW51bWVyaWModGV4dCkge1xuICByZXR1cm4gQUxQSEFOVU1FUklDX1JFR0VYLnRlc3QodGV4dCk7XG59XG5mdW5jdGlvbiBnZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbikge1xuICBsZXQgcmVzdWx0ID0gMDtcbiAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgIGNvbnN0IGNjYml0cyA9IG51bUNoYXJDb3VudEJpdHMoc2VnLm1vZGUsIHZlcnNpb24pO1xuICAgIGlmIChzZWcubnVtQ2hhcnMgPj0gMSA8PCBjY2JpdHMpXG4gICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHJlc3VsdCArPSA0ICsgY2NiaXRzICsgc2VnLmJpdERhdGEubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1V0ZjhCeXRlQXJyYXkoc3RyKSB7XG4gIHN0ciA9IGVuY29kZVVSSShzdHIpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChpKSAhPT0gXCIlXCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goTnVtYmVyLnBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSArIDEsIGkgKyAzKSwgMTYpKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE51bVJhd0RhdGFNb2R1bGVzKHZlcikge1xuICBpZiAodmVyIDwgTUlOX1ZFUlNJT04gfHwgdmVyID4gTUFYX1ZFUlNJT04pXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWZXJzaW9uIG51bWJlciBvdXQgb2YgcmFuZ2VcIik7XG4gIGxldCByZXN1bHQgPSAoMTYgKiB2ZXIgKyAxMjgpICogdmVyICsgNjQ7XG4gIGlmICh2ZXIgPj0gMikge1xuICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih2ZXIgLyA3KSArIDI7XG4gICAgcmVzdWx0IC09ICgyNSAqIG51bUFsaWduIC0gMTApICogbnVtQWxpZ24gLSA1NTtcbiAgICBpZiAodmVyID49IDcpXG4gICAgICByZXN1bHQgLT0gMzY7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpIC0gRUNDX0NPREVXT1JEU19QRVJfQkxPQ0tbZWNsWzBdXVt2ZXJdICogTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTW2VjbFswXV1bdmVyXTtcbn1cbmZ1bmN0aW9uIHJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoZGVncmVlKSB7XG4gIGlmIChkZWdyZWUgPCAxIHx8IGRlZ3JlZSA+IDI1NSlcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlZ3JlZSBvdXQgb2YgcmFuZ2VcIik7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSAtIDE7IGkrKylcbiAgICByZXN1bHQucHVzaCgwKTtcbiAgcmVzdWx0LnB1c2goMSk7XG4gIGxldCByb290ID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWU7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbal0gPSByZWVkU29sb21vbk11bHRpcGx5KHJlc3VsdFtqXSwgcm9vdCk7XG4gICAgICBpZiAoaiArIDEgPCByZXN1bHQubGVuZ3RoKVxuICAgICAgICByZXN1bHRbal0gXj0gcmVzdWx0W2ogKyAxXTtcbiAgICB9XG4gICAgcm9vdCA9IHJlZWRTb2xvbW9uTXVsdGlwbHkocm9vdCwgMik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlZWRTb2xvbW9uQ29tcHV0ZVJlbWFpbmRlcihkYXRhLCBkaXZpc29yKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGRpdmlzb3IubWFwKChfKSA9PiAwKTtcbiAgZm9yIChjb25zdCBiIG9mIGRhdGEpIHtcbiAgICBjb25zdCBmYWN0b3IgPSBiIF4gcmVzdWx0LnNoaWZ0KCk7XG4gICAgcmVzdWx0LnB1c2goMCk7XG4gICAgZGl2aXNvci5mb3JFYWNoKChjb2VmLCBpKSA9PiByZXN1bHRbaV0gXj0gcmVlZFNvbG9tb25NdWx0aXBseShjb2VmLCBmYWN0b3IpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVlZFNvbG9tb25NdWx0aXBseSh4LCB5KSB7XG4gIGlmICh4ID4+PiA4ICE9PSAwIHx8IHkgPj4+IDggIT09IDApXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCeXRlIG91dCBvZiByYW5nZVwiKTtcbiAgbGV0IHogPSAwO1xuICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICB6ID0geiA8PCAxIF4gKHogPj4+IDcpICogMjg1O1xuICAgIHogXj0gKHkgPj4+IGkgJiAxKSAqIHg7XG4gIH1cbiAgcmV0dXJuIHo7XG59XG5mdW5jdGlvbiBlbmNvZGVTZWdtZW50cyhzZWdzLCBlY2wsIG1pblZlcnNpb24gPSAxLCBtYXhWZXJzaW9uID0gNDAsIG1hc2sgPSAtMSwgYm9vc3RFY2wgPSB0cnVlKSB7XG4gIGlmICghKE1JTl9WRVJTSU9OIDw9IG1pblZlcnNpb24gJiYgbWluVmVyc2lvbiA8PSBtYXhWZXJzaW9uICYmIG1heFZlcnNpb24gPD0gTUFYX1ZFUlNJT04pIHx8IG1hc2sgPCAtMSB8fCBtYXNrID4gNylcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWVcIik7XG4gIGxldCB2ZXJzaW9uO1xuICBsZXQgZGF0YVVzZWRCaXRzO1xuICBmb3IgKHZlcnNpb24gPSBtaW5WZXJzaW9uOyA7IHZlcnNpb24rKykge1xuICAgIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHMyID0gZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODtcbiAgICBjb25zdCB1c2VkQml0cyA9IGdldFRvdGFsQml0cyhzZWdzLCB2ZXJzaW9uKTtcbiAgICBpZiAodXNlZEJpdHMgPD0gZGF0YUNhcGFjaXR5Qml0czIpIHtcbiAgICAgIGRhdGFVc2VkQml0cyA9IHVzZWRCaXRzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID49IG1heFZlcnNpb24pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRhdGEgdG9vIGxvbmdcIik7XG4gIH1cbiAgZm9yIChjb25zdCBuZXdFY2wgb2YgW01FRElVTSwgUVVBUlRJTEUsIEhJR0hdKSB7XG4gICAgaWYgKGJvb3N0RWNsICYmIGRhdGFVc2VkQml0cyA8PSBnZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIG5ld0VjbCkgKiA4KVxuICAgICAgZWNsID0gbmV3RWNsO1xuICB9XG4gIGNvbnN0IGJiID0gW107XG4gIGZvciAoY29uc3Qgc2VnIG9mIHNlZ3MpIHtcbiAgICBhcHBlbmRCaXRzKHNlZy5tb2RlWzBdLCA0LCBiYik7XG4gICAgYXBwZW5kQml0cyhzZWcubnVtQ2hhcnMsIG51bUNoYXJDb3VudEJpdHMoc2VnLm1vZGUsIHZlcnNpb24pLCBiYik7XG4gICAgZm9yIChjb25zdCBiIG9mIHNlZy5nZXREYXRhKCkpXG4gICAgICBiYi5wdXNoKGIpO1xuICB9XG4gIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHMgPSBnZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICBhcHBlbmRCaXRzKDAsIE1hdGgubWluKDQsIGRhdGFDYXBhY2l0eUJpdHMgLSBiYi5sZW5ndGgpLCBiYik7XG4gIGFwcGVuZEJpdHMoMCwgKDggLSBiYi5sZW5ndGggJSA4KSAlIDgsIGJiKTtcbiAgZm9yIChsZXQgcGFkQnl0ZSA9IDIzNjsgYmIubGVuZ3RoIDwgZGF0YUNhcGFjaXR5Qml0czsgcGFkQnl0ZSBePSAyMzYgXiAxNylcbiAgICBhcHBlbmRCaXRzKHBhZEJ5dGUsIDgsIGJiKTtcbiAgY29uc3QgZGF0YUNvZGV3b3JkcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IE1hdGguY2VpbChiYi5sZW5ndGggLyA4KSB9LCAoKSA9PiAwKTtcbiAgYmIuZm9yRWFjaCgoYiwgaSkgPT4gZGF0YUNvZGV3b3Jkc1tpID4+PiAzXSB8PSBiIDw8IDcgLSAoaSAmIDcpKTtcbiAgcmV0dXJuIG5ldyBRckNvZGUodmVyc2lvbiwgZWNsLCBkYXRhQ29kZXdvcmRzLCBtYXNrKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGVjYyA9IFwiTFwiLFxuICAgIGJvb3N0RWNjID0gZmFsc2UsXG4gICAgbWluVmVyc2lvbiA9IDEsXG4gICAgbWF4VmVyc2lvbiA9IDQwLFxuICAgIG1hc2tQYXR0ZXJuID0gLTEsXG4gICAgYm9yZGVyID0gMVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgc2VnbWVudCA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gbWFrZVNlZ21lbnRzKGRhdGEpIDogQXJyYXkuaXNBcnJheShkYXRhKSA/IFttYWtlQnl0ZXMoZGF0YSldIDogdm9pZCAwO1xuICBpZiAoIXNlZ21lbnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1cXIgb25seSBzdXBwb3J0cyBlbmNvZGluZyBzdHJpbmcgYW5kIGJpbmFyeSBkYXRhLCBidXQgZ290OiAke3R5cGVvZiBkYXRhfWApO1xuICBjb25zdCBxciA9IGVuY29kZVNlZ21lbnRzKFxuICAgIHNlZ21lbnQsXG4gICAgRWNjTWFwW2VjY10sXG4gICAgbWluVmVyc2lvbixcbiAgICBtYXhWZXJzaW9uLFxuICAgIG1hc2tQYXR0ZXJuLFxuICAgIGJvb3N0RWNjXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IGFkZEJvcmRlcih7XG4gICAgdmVyc2lvbjogcXIudmVyc2lvbixcbiAgICBtYXNrUGF0dGVybjogcXIubWFzayxcbiAgICBzaXplOiBxci5zaXplLFxuICAgIGRhdGE6IHFyLm1vZHVsZXMsXG4gICAgdHlwZXM6IHFyLnR5cGVzXG4gIH0sIGJvcmRlcik7XG4gIGlmIChvcHRpb25zPy5pbnZlcnQpXG4gICAgcmVzdWx0LmRhdGEgPSByZXN1bHQuZGF0YS5tYXAoKHJvdykgPT4gcm93Lm1hcCgobW9kKSA9PiAhbW9kKSk7XG4gIG9wdGlvbnM/Lm9uRW5jb2RlZD8uKHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhZGRCb3JkZXIoaW5wdXQsIGJvcmRlciA9IDEpIHtcbiAgaWYgKCFib3JkZXIpXG4gICAgcmV0dXJuIGlucHV0O1xuICBjb25zdCB7IHNpemUgfSA9IGlucHV0O1xuICBjb25zdCBuZXdTaXplID0gc2l6ZSArIGJvcmRlciAqIDI7XG4gIGlucHV0LnNpemUgPSBuZXdTaXplO1xuICBpbnB1dC5kYXRhLmZvckVhY2goKHJvdykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9yZGVyOyBpKyspIHtcbiAgICAgIHJvdy51bnNoaWZ0KGZhbHNlKTtcbiAgICAgIHJvdy5wdXNoKGZhbHNlKTtcbiAgICB9XG4gIH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvcmRlcjsgaSsrKSB7XG4gICAgaW5wdXQuZGF0YS51bnNoaWZ0KEFycmF5LmZyb20oeyBsZW5ndGg6IG5ld1NpemUgfSwgKF8pID0+IGZhbHNlKSk7XG4gICAgaW5wdXQuZGF0YS5wdXNoKEFycmF5LmZyb20oeyBsZW5ndGg6IG5ld1NpemUgfSwgKF8pID0+IGZhbHNlKSk7XG4gIH1cbiAgY29uc3QgYiA9IFFyQ29kZURhdGFUeXBlLkJvcmRlcjtcbiAgaW5wdXQudHlwZXMuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3JkZXI7IGkrKykge1xuICAgICAgcm93LnVuc2hpZnQoYik7XG4gICAgICByb3cucHVzaChiKTtcbiAgICB9XG4gIH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvcmRlcjsgaSsrKSB7XG4gICAgaW5wdXQudHlwZXMudW5zaGlmdChBcnJheS5mcm9tKHsgbGVuZ3RoOiBuZXdTaXplIH0sIChfKSA9PiBiKSk7XG4gICAgaW5wdXQudHlwZXMucHVzaChBcnJheS5mcm9tKHsgbGVuZ3RoOiBuZXdTaXplIH0sIChfKSA9PiBiKSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuZnVuY3Rpb24gZ2V0RGF0YUF0KGRhdGEsIHgsIHksIGRlZmF1bHRzID0gZmFsc2UpIHtcbiAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gZGF0YS5sZW5ndGggfHwgeSA+PSBkYXRhLmxlbmd0aClcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIHJldHVybiBkYXRhW3ldW3hdO1xufVxuXG5mdW5jdGlvbiByZW5kZXJVbmljb2RlKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2hpdGVDaGFyID0gXCJcXHUyNTg4XCIsXG4gICAgYmxhY2tDaGFyID0gXCJcXHUyNTkxXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlc3VsdCA9IGVuY29kZShkYXRhLCBvcHRpb25zKTtcbiAgcmV0dXJuIHJlc3VsdC5kYXRhLm1hcCgocm93KSA9PiB7XG4gICAgcmV0dXJuIHJvdy5tYXAoKG1vZCkgPT4gbW9kID8gYmxhY2tDaGFyIDogd2hpdGVDaGFyKS5qb2luKFwiXCIpO1xuICB9KS5qb2luKFwiXFxuXCIpO1xufVxuZnVuY3Rpb24gcmVuZGVyQU5TSShkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHJlbmRlclVuaWNvZGUoZGF0YSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYmxhY2tDaGFyOiBcIlxceDFCWzQwbVxcdTMwMDBcXHgxQlswbVwiLFxuICAgIHdoaXRlQ2hhcjogXCJcXHgxQls0N21cXHUzMDAwXFx4MUJbMG1cIlxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclVuaWNvZGVDb21wYWN0KGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwbGF0dGUgPSB7XG4gICAgV0hJVEVfQUxMOiBcIlxcdTI1ODhcIixcbiAgICBXSElURV9CTEFDSzogXCJcXHUyNTgwXCIsXG4gICAgQkxBQ0tfV0hJVEU6IFwiXFx1MjU4NFwiLFxuICAgIEJMQUNLX0FMTDogXCIgXCJcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0gZW5jb2RlKGRhdGEsIG9wdGlvbnMpO1xuICBjb25zdCBXSElURSA9IGZhbHNlO1xuICBjb25zdCBCTEFDSyA9IHRydWU7XG4gIGNvbnN0IGF0ID0gKHgsIHkpID0+IGdldERhdGFBdChyZXN1bHQuZGF0YSwgeCwgeSwgdHJ1ZSk7XG4gIGNvbnN0IGxpbmVzID0gW107XG4gIGxldCBsaW5lID0gXCJcIjtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcmVzdWx0LnNpemU7IHJvdyArPSAyKSB7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgcmVzdWx0LnNpemU7IGNvbCsrKSB7XG4gICAgICBpZiAoYXQoY29sLCByb3cpID09PSBXSElURSAmJiBhdChjb2wsIHJvdyArIDEpID09PSBXSElURSlcbiAgICAgICAgbGluZSArPSBwbGF0dGUuV0hJVEVfQUxMO1xuICAgICAgZWxzZSBpZiAoYXQoY29sLCByb3cpID09PSBXSElURSAmJiBhdChjb2wsIHJvdyArIDEpID09PSBCTEFDSylcbiAgICAgICAgbGluZSArPSBwbGF0dGUuV0hJVEVfQkxBQ0s7XG4gICAgICBlbHNlIGlmIChhdChjb2wsIHJvdykgPT09IEJMQUNLICYmIGF0KGNvbCwgcm93ICsgMSkgPT09IFdISVRFKVxuICAgICAgICBsaW5lICs9IHBsYXR0ZS5CTEFDS19XSElURTtcbiAgICAgIGVsc2VcbiAgICAgICAgbGluZSArPSBwbGF0dGUuQkxBQ0tfQUxMO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgIGxpbmUgPSBcIlwiO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTVkcoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGVuY29kZShkYXRhLCBvcHRpb25zKTtcbiAgY29uc3Qge1xuICAgIHBpeGVsU2l6ZSA9IDEwLFxuICAgIHdoaXRlQ29sb3IgPSBcIndoaXRlXCIsXG4gICAgYmxhY2tDb2xvciA9IFwiYmxhY2tcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaGVpZ2h0ID0gcmVzdWx0LnNpemUgKiBwaXhlbFNpemU7XG4gIGNvbnN0IHdpZHRoID0gcmVzdWx0LnNpemUgKiBwaXhlbFNpemU7XG4gIGxldCBzdmcgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAke3dpZHRofSAke2hlaWdodH1cIj5gO1xuICBjb25zdCBwYXRoZXMgPSBbXTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcmVzdWx0LnNpemU7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgcmVzdWx0LnNpemU7IGNvbCsrKSB7XG4gICAgICBjb25zdCB4ID0gY29sICogcGl4ZWxTaXplO1xuICAgICAgY29uc3QgeSA9IHJvdyAqIHBpeGVsU2l6ZTtcbiAgICAgIGlmIChyZXN1bHQuZGF0YVtyb3ddW2NvbF0pXG4gICAgICAgIHBhdGhlcy5wdXNoKGBNJHt4fSwke3l9aCR7cGl4ZWxTaXplfXYke3BpeGVsU2l6ZX1oLSR7cGl4ZWxTaXplfXpgKTtcbiAgICB9XG4gIH1cbiAgc3ZnICs9IGA8cmVjdCBmaWxsPVwiJHt3aGl0ZUNvbG9yfVwiIHdpZHRoPVwiJHt3aWR0aH1cIiBoZWlnaHQ9XCIke2hlaWdodH1cIi8+YDtcbiAgc3ZnICs9IGA8cGF0aCBmaWxsPVwiJHtibGFja0NvbG9yfVwiIGQ9XCIke3BhdGhlcy5qb2luKFwiXCIpfVwiLz5gO1xuICBzdmcgKz0gXCI8L3N2Zz5cIjtcbiAgcmV0dXJuIHN2Zztcbn1cblxuZXhwb3J0IHsgUXJDb2RlRGF0YVR5cGUsIGVuY29kZSwgcmVuZGVyQU5TSSwgcmVuZGVyU1ZHLCByZW5kZXJVbmljb2RlLCByZW5kZXJVbmljb2RlQ29tcGFjdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uqr/dist/index.mjs\n");

/***/ })

};
;