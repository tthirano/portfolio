"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/proxy-compare";
exports.ids = ["vendor-chunks/proxy-compare"];
exports.modules = {

/***/ "(ssr)/./node_modules/proxy-compare/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/proxy-compare/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   affectedToPathList: () => (/* binding */ affectedToPathList),\n/* harmony export */   createProxy: () => (/* binding */ createProxy),\n/* harmony export */   getUntracked: () => (/* binding */ getUntracked),\n/* harmony export */   isChanged: () => (/* binding */ isChanged),\n/* harmony export */   markToTrack: () => (/* binding */ markToTrack),\n/* harmony export */   replaceNewProxy: () => (/* binding */ replaceNewProxy),\n/* harmony export */   trackMemo: () => (/* binding */ trackMemo)\n/* harmony export */ });\n/* eslint @typescript-eslint/no-explicit-any: off */\n// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n// function to create a new bare proxy\nlet newProxy = (target, handler) => new Proxy(target, handler);\n// get object prototype\nconst getProto = Object.getPrototypeOf;\nconst objectsToTrack = new WeakMap();\n// check if obj is a plain object or an array\nconst isObjectToTrack = (obj) => obj &&\n    (objectsToTrack.has(obj)\n        ? objectsToTrack.get(obj)\n        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);\n// check if it is object\nconst isObject = (x) => typeof x === 'object' && x !== null;\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = (obj) => {\n    if (Array.isArray(obj)) {\n        // Arrays need a special way to copy\n        return Array.from(obj);\n    }\n    // For non-array objects, we create a new object keeping the prototype\n    // with changing all configurable options (otherwise, proxies will complain)\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    Object.values(descriptors).forEach((desc) => {\n        desc.configurable = true;\n    });\n    return Object.create(getProto(obj), descriptors);\n};\nconst createProxyHandler = (origObj, isTargetCopied) => {\n    const state = {\n        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n    };\n    let trackObject = false; // for trackMemo\n    const recordUsage = (type, key) => {\n        if (!trackObject) {\n            let used = state[AFFECTED_PROPERTY].get(origObj);\n            if (!used) {\n                used = {};\n                state[AFFECTED_PROPERTY].set(origObj, used);\n            }\n            if (type === ALL_OWN_KEYS_PROPERTY) {\n                used[ALL_OWN_KEYS_PROPERTY] = true;\n            }\n            else {\n                let set = used[type];\n                if (!set) {\n                    set = new Set();\n                    used[type] = set;\n                }\n                set.add(key);\n            }\n        }\n    };\n    const recordObjectAsUsed = () => {\n        trackObject = true;\n        state[AFFECTED_PROPERTY].delete(origObj);\n    };\n    const handler = {\n        get(target, key) {\n            if (key === GET_ORIGINAL_SYMBOL) {\n                return origObj;\n            }\n            recordUsage(KEYS_PROPERTY, key);\n            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);\n        },\n        has(target, key) {\n            if (key === TRACK_MEMO_SYMBOL) {\n                recordObjectAsUsed();\n                return true;\n            }\n            recordUsage(HAS_KEY_PROPERTY, key);\n            return Reflect.has(target, key);\n        },\n        getOwnPropertyDescriptor(target, key) {\n            recordUsage(HAS_OWN_KEY_PROPERTY, key);\n            return Reflect.getOwnPropertyDescriptor(target, key);\n        },\n        ownKeys(target) {\n            recordUsage(ALL_OWN_KEYS_PROPERTY);\n            return Reflect.ownKeys(target);\n        },\n    };\n    if (isTargetCopied) {\n        handler.set = handler.deleteProperty = () => false;\n    }\n    return [handler, state];\n};\nconst getOriginalObject = (obj) => \n// unwrap proxy\nobj[GET_ORIGINAL_SYMBOL] ||\n    // otherwise\n    obj;\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nconst createProxy = (obj, affected, proxyCache, targetCache) => {\n    if (!isObjectToTrack(obj))\n        return obj;\n    let targetAndCopied = targetCache && targetCache.get(obj);\n    if (!targetAndCopied) {\n        const target = getOriginalObject(obj);\n        if (needsToCopyTargetObject(target)) {\n            targetAndCopied = [target, copyTargetObject(target)];\n        }\n        else {\n            targetAndCopied = [target];\n        }\n        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);\n    }\n    const [target, copiedTarget] = targetAndCopied;\n    let handlerAndState = proxyCache && proxyCache.get(target);\n    if (!handlerAndState ||\n        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {\n        handlerAndState = createProxyHandler(target, !!copiedTarget);\n        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);\n        if (proxyCache) {\n            proxyCache.set(target, handlerAndState);\n        }\n    }\n    handlerAndState[1][AFFECTED_PROPERTY] = affected;\n    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;\n    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;\n    return handlerAndState[1][PROXY_PROPERTY];\n};\nconst isAllOwnKeysChanged = (prevObj, nextObj) => {\n    const prevKeys = Reflect.ownKeys(prevObj);\n    const nextKeys = Reflect.ownKeys(nextObj);\n    return (prevKeys.length !== nextKeys.length ||\n        prevKeys.some((k, i) => k !== nextKeys[i]));\n};\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\nconst isChanged = (prevObj, nextObj, affected, cache, // for object with cycles\nisEqual = Object.is) => {\n    if (isEqual(prevObj, nextObj)) {\n        return false;\n    }\n    if (!isObject(prevObj) || !isObject(nextObj))\n        return true;\n    const used = affected.get(getOriginalObject(prevObj));\n    if (!used)\n        return true;\n    if (cache) {\n        const hit = cache.get(prevObj);\n        if (hit === nextObj) {\n            return false;\n        }\n        // for object with cycles\n        cache.set(prevObj, nextObj);\n    }\n    let changed = null;\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n        changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n        if (changed)\n            return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        changed = isAllOwnKeysChanged(prevObj, nextObj);\n        if (changed)\n            return changed;\n    }\n    else {\n        for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n            const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n            const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n            changed = hasPrev !== hasNext;\n            if (changed)\n                return changed;\n        }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n        changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);\n        if (changed)\n            return changed;\n    }\n    if (changed === null)\n        throw new Error('invalid used');\n    return changed;\n};\n// explicitly track object with memo\nconst trackMemo = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return TRACK_MEMO_SYMBOL in obj;\n    }\n    return false;\n};\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nconst getUntracked = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return obj[GET_ORIGINAL_SYMBOL] || null;\n    }\n    return null;\n};\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nconst markToTrack = (obj, mark = true) => {\n    objectsToTrack.set(obj, mark);\n};\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nconst affectedToPathList = (obj, affected, onlyWithValues) => {\n    const list = [];\n    const seen = new WeakSet();\n    const walk = (x, path) => {\n        var _a, _b, _c;\n        if (seen.has(x)) {\n            // for object with cycles\n            return;\n        }\n        if (isObject(x)) {\n            seen.add(x);\n        }\n        const used = isObject(x) && affected.get(getOriginalObject(x));\n        if (used) {\n            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const segment = `:has(${String(key)})`;\n                list.push(path ? [...path, segment] : [segment]);\n            });\n            if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n                const segment = ':ownKeys';\n                list.push(path ? [...path, segment] : [segment]);\n            }\n            else {\n                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n                    const segment = `:hasOwn(${String(key)})`;\n                    list.push(path ? [...path, segment] : [segment]);\n                });\n            }\n            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n                if (!onlyWithValues ||\n                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n                    walk(x[key], path ? [...path, key] : [key]);\n                }\n            });\n        }\n        else if (path) {\n            list.push(path);\n        }\n    };\n    walk(obj);\n    return list;\n};\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nconst replaceNewProxy = (fn) => {\n    newProxy = fn;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJveHktY29tcGFyZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDBCQUEwQjtBQUNyQztBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLFVBQVU7QUFDeEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdHlsZXJcXERlc2t0b3BcXHJlc3VtZVxccmVzdW1lXFxub2RlX21vZHVsZXNcXHByb3h5LWNvbXBhcmVcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55OiBvZmYgKi9cbi8vIHN5bWJvbHNcbmNvbnN0IFRSQUNLX01FTU9fU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBHRVRfT1JJR0lOQUxfU1lNQk9MID0gU3ltYm9sKCk7XG4vLyBwcm9wZXJ0aWVzXG5jb25zdCBBRkZFQ1RFRF9QUk9QRVJUWSA9ICdhJztcbmNvbnN0IElTX1RBUkdFVF9DT1BJRURfUFJPUEVSVFkgPSAnZic7XG5jb25zdCBQUk9YWV9QUk9QRVJUWSA9ICdwJztcbmNvbnN0IFBST1hZX0NBQ0hFX1BST1BFUlRZID0gJ2MnO1xuY29uc3QgVEFSR0VUX0NBQ0hFX1BST1BFUlRZID0gJ3QnO1xuY29uc3QgSEFTX0tFWV9QUk9QRVJUWSA9ICdoJztcbmNvbnN0IEFMTF9PV05fS0VZU19QUk9QRVJUWSA9ICd3JztcbmNvbnN0IEhBU19PV05fS0VZX1BST1BFUlRZID0gJ28nO1xuY29uc3QgS0VZU19QUk9QRVJUWSA9ICdrJztcbi8vIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBiYXJlIHByb3h5XG5sZXQgbmV3UHJveHkgPSAodGFyZ2V0LCBoYW5kbGVyKSA9PiBuZXcgUHJveHkodGFyZ2V0LCBoYW5kbGVyKTtcbi8vIGdldCBvYmplY3QgcHJvdG90eXBlXG5jb25zdCBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmNvbnN0IG9iamVjdHNUb1RyYWNrID0gbmV3IFdlYWtNYXAoKTtcbi8vIGNoZWNrIGlmIG9iaiBpcyBhIHBsYWluIG9iamVjdCBvciBhbiBhcnJheVxuY29uc3QgaXNPYmplY3RUb1RyYWNrID0gKG9iaikgPT4gb2JqICYmXG4gICAgKG9iamVjdHNUb1RyYWNrLmhhcyhvYmopXG4gICAgICAgID8gb2JqZWN0c1RvVHJhY2suZ2V0KG9iailcbiAgICAgICAgOiBnZXRQcm90byhvYmopID09PSBPYmplY3QucHJvdG90eXBlIHx8IGdldFByb3RvKG9iaikgPT09IEFycmF5LnByb3RvdHlwZSk7XG4vLyBjaGVjayBpZiBpdCBpcyBvYmplY3RcbmNvbnN0IGlzT2JqZWN0ID0gKHgpID0+IHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuLy8gUHJvcGVydGllcyB0aGF0IGFyZSBib3RoIG5vbi1jb25maWd1cmFibGUgYW5kIG5vbi13cml0YWJsZSB3aWxsIGJyZWFrXG4vLyB0aGUgcHJveHkgZ2V0IHRyYXAgd2hlbiB3ZSB0cnkgdG8gcmV0dXJuIGEgcmVjdXJzaXZlL2NoaWxkIGNvbXBhcmUgcHJveHlcbi8vIGZyb20gdGhlbS4gV2UgY2FuIGF2b2lkIHRoaXMgYnkgbWFraW5nIGEgY29weSBvZiB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoXG4vLyBhbGwgZGVzY3JpcHRvcnMgbWFya2VkIGFzIGNvbmZpZ3VyYWJsZSwgc2VlIGBjb3B5VGFyZ2V0T2JqZWN0YC5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhaS1zaGkvcHJveHktY29tcGFyZS9wdWxsLzhcbmNvbnN0IG5lZWRzVG9Db3B5VGFyZ2V0T2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnZhbHVlcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKS5zb21lKChkZXNjcmlwdG9yKSA9PiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUgJiYgIWRlc2NyaXB0b3Iud3JpdGFibGUpO1xuLy8gTWFrZSBhIGNvcHkgd2l0aCBhbGwgZGVzY3JpcHRvcnMgbWFya2VkIGFzIGNvbmZpZ3VyYWJsZS5cbmNvbnN0IGNvcHlUYXJnZXRPYmplY3QgPSAob2JqKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyBBcnJheXMgbmVlZCBhIHNwZWNpYWwgd2F5IHRvIGNvcHlcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ob2JqKTtcbiAgICB9XG4gICAgLy8gRm9yIG5vbi1hcnJheSBvYmplY3RzLCB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IGtlZXBpbmcgdGhlIHByb3RvdHlwZVxuICAgIC8vIHdpdGggY2hhbmdpbmcgYWxsIGNvbmZpZ3VyYWJsZSBvcHRpb25zIChvdGhlcndpc2UsIHByb3hpZXMgd2lsbCBjb21wbGFpbilcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gICAgT2JqZWN0LnZhbHVlcyhkZXNjcmlwdG9ycykuZm9yRWFjaCgoZGVzYykgPT4ge1xuICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZ2V0UHJvdG8ob2JqKSwgZGVzY3JpcHRvcnMpO1xufTtcbmNvbnN0IGNyZWF0ZVByb3h5SGFuZGxlciA9IChvcmlnT2JqLCBpc1RhcmdldENvcGllZCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBbSVNfVEFSR0VUX0NPUElFRF9QUk9QRVJUWV06IGlzVGFyZ2V0Q29waWVkLFxuICAgIH07XG4gICAgbGV0IHRyYWNrT2JqZWN0ID0gZmFsc2U7IC8vIGZvciB0cmFja01lbW9cbiAgICBjb25zdCByZWNvcmRVc2FnZSA9ICh0eXBlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCF0cmFja09iamVjdCkge1xuICAgICAgICAgICAgbGV0IHVzZWQgPSBzdGF0ZVtBRkZFQ1RFRF9QUk9QRVJUWV0uZ2V0KG9yaWdPYmopO1xuICAgICAgICAgICAgaWYgKCF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdXNlZCA9IHt9O1xuICAgICAgICAgICAgICAgIHN0YXRlW0FGRkVDVEVEX1BST1BFUlRZXS5zZXQob3JpZ09iaiwgdXNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gQUxMX09XTl9LRVlTX1BST1BFUlRZKSB7XG4gICAgICAgICAgICAgICAgdXNlZFtBTExfT1dOX0tFWVNfUFJPUEVSVFldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzZXQgPSB1c2VkW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdXNlZFt0eXBlXSA9IHNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWNvcmRPYmplY3RBc1VzZWQgPSAoKSA9PiB7XG4gICAgICAgIHRyYWNrT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgc3RhdGVbQUZGRUNURURfUFJPUEVSVFldLmRlbGV0ZShvcmlnT2JqKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gR0VUX09SSUdJTkFMX1NZTUJPTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkVXNhZ2UoS0VZU19QUk9QRVJUWSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShSZWZsZWN0LmdldCh0YXJnZXQsIGtleSksIHN0YXRlW0FGRkVDVEVEX1BST1BFUlRZXSwgc3RhdGVbUFJPWFlfQ0FDSEVfUFJPUEVSVFldLCBzdGF0ZVtUQVJHRVRfQ0FDSEVfUFJPUEVSVFldKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBUUkFDS19NRU1PX1NZTUJPTCkge1xuICAgICAgICAgICAgICAgIHJlY29yZE9iamVjdEFzVXNlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkVXNhZ2UoSEFTX0tFWV9QUk9QRVJUWSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgcmVjb3JkVXNhZ2UoSEFTX09XTl9LRVlfUFJPUEVSVFksIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgICAgICAgcmVjb3JkVXNhZ2UoQUxMX09XTl9LRVlTX1BST1BFUlRZKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChpc1RhcmdldENvcGllZCkge1xuICAgICAgICBoYW5kbGVyLnNldCA9IGhhbmRsZXIuZGVsZXRlUHJvcGVydHkgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFtoYW5kbGVyLCBzdGF0ZV07XG59O1xuY29uc3QgZ2V0T3JpZ2luYWxPYmplY3QgPSAob2JqKSA9PiBcbi8vIHVud3JhcCBwcm94eVxub2JqW0dFVF9PUklHSU5BTF9TWU1CT0xdIHx8XG4gICAgLy8gb3RoZXJ3aXNlXG4gICAgb2JqO1xuLyoqXG4gKiBDcmVhdGUgYSBwcm94eS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgcHJveHkgYXQgdG9wIGxldmVsIGFuZCBwcm94eSBuZXN0ZWQgb2JqZWN0cyBhcyB5b3UgYWNjZXNzIHRoZW0sXG4gKiBpbiBvcmRlciB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHByb3BlcnRpZXMgd2VyZSBhY2Nlc3NlZCB2aWEgZ2V0L2hhcyBwcm94eSBoYW5kbGVyczpcbiAqXG4gKiBOT1RFOiBQcmludGluZyBvZiBXZWFrTWFwIGlzIGhhcmQgdG8gaW5zcGVjdCBhbmQgbm90IHZlcnkgcmVhZGFibGVcbiAqIGZvciB0aGlzIHB1cnBvc2UgeW91IGNhbiB1c2UgdGhlIGBhZmZlY3RlZFRvUGF0aExpc3RgIGhlbHBlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gT2JqZWN0IHRoYXQgd2lsbCBiZSB3cmFwcGVkIG9uIHRoZSBwcm94eS5cbiAqIEBwYXJhbSB7V2Vha01hcDxvYmplY3QsIHVua25vd24+fSBhZmZlY3RlZCAtXG4gKiBXZWFrTWFwIHRoYXQgd2lsbCBob2xkIHRoZSB0cmFja2luZyBvZiB3aGljaCBwcm9wZXJ0aWVzIGluIHRoZSBwcm94aWVkIG9iamVjdCB3ZXJlIGFjY2Vzc2VkLlxuICogQHBhcmFtIHtXZWFrTWFwPG9iamVjdCwgdW5rbm93bj59IFtwcm94eUNhY2hlXSAtXG4gKiBXZWFrTWFwIHRoYXQgd2lsbCBoZWxwIGtlZXAgcmVmZXJlbnRpYWwgaWRlbnRpdHkgZm9yIHByb3hpZXMuXG4gKiBAcmV0dXJucyB7UHJveHk8b2JqZWN0Pn0gLSBPYmplY3Qgd3JhcHBlZCBpbiBhIHByb3h5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBjcmVhdGVQcm94eSB9IGZyb20gJ3Byb3h5LWNvbXBhcmUnO1xuICpcbiAqIGNvbnN0IG9yaWdpbmFsID0geyBhOiBcIjFcIiwgYzogXCIyXCIsIGQ6IHsgZTogXCIzXCIgfSB9O1xuICogY29uc3QgYWZmZWN0ZWQgPSBuZXcgV2Vha01hcCgpO1xuICogY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShvcmlnaW5hbCwgYWZmZWN0ZWQpO1xuICpcbiAqIHByb3h5LmEgLy8gV2lsbCBtYXJrIGFzIHVzZWQgYW5kIHRyYWNrIGl0cyB2YWx1ZS5cbiAqIC8vIFRoaXMgd2lsbCB1cGRhdGUgdGhlIGFmZmVjdGVkIFdlYWtNYXAgd2l0aCBvcmlnaW5hbCBhcyBrZXlcbiAqIC8vIGFuZCBhIFNldCB3aXRoIFwiYVwiXG4gKlxuICogcHJveHkuZCAvLyBXaWxsIG1hcmsgXCJkXCIgYXMgYWNjZXNzZWQgdG8gdHJhY2sgYW5kIHByb3h5IGl0c2VsZiAoeyBlOiBcIjNcIiB9KS5cbiAqIC8vIFRoaXMgd2lsbCB1cGRhdGUgdGhlIGFmZmVjdGVkIFdlYWtNYXAgd2l0aCBvcmlnaW5hbCBhcyBrZXlcbiAqIC8vIGFuZCBhIFNldCB3aXRoIFwiZFwiXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm94eSA9IChvYmosIGFmZmVjdGVkLCBwcm94eUNhY2hlLCB0YXJnZXRDYWNoZSkgPT4ge1xuICAgIGlmICghaXNPYmplY3RUb1RyYWNrKG9iaikpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgbGV0IHRhcmdldEFuZENvcGllZCA9IHRhcmdldENhY2hlICYmIHRhcmdldENhY2hlLmdldChvYmopO1xuICAgIGlmICghdGFyZ2V0QW5kQ29waWVkKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldE9yaWdpbmFsT2JqZWN0KG9iaik7XG4gICAgICAgIGlmIChuZWVkc1RvQ29weVRhcmdldE9iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXRBbmRDb3BpZWQgPSBbdGFyZ2V0LCBjb3B5VGFyZ2V0T2JqZWN0KHRhcmdldCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0QW5kQ29waWVkID0gW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0Q2FjaGUgPT09IG51bGwgfHwgdGFyZ2V0Q2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldENhY2hlLnNldChvYmosIHRhcmdldEFuZENvcGllZCk7XG4gICAgfVxuICAgIGNvbnN0IFt0YXJnZXQsIGNvcGllZFRhcmdldF0gPSB0YXJnZXRBbmRDb3BpZWQ7XG4gICAgbGV0IGhhbmRsZXJBbmRTdGF0ZSA9IHByb3h5Q2FjaGUgJiYgcHJveHlDYWNoZS5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWhhbmRsZXJBbmRTdGF0ZSB8fFxuICAgICAgICBoYW5kbGVyQW5kU3RhdGVbMV1bSVNfVEFSR0VUX0NPUElFRF9QUk9QRVJUWV0gIT09ICEhY29waWVkVGFyZ2V0KSB7XG4gICAgICAgIGhhbmRsZXJBbmRTdGF0ZSA9IGNyZWF0ZVByb3h5SGFuZGxlcih0YXJnZXQsICEhY29waWVkVGFyZ2V0KTtcbiAgICAgICAgaGFuZGxlckFuZFN0YXRlWzFdW1BST1hZX1BST1BFUlRZXSA9IG5ld1Byb3h5KGNvcGllZFRhcmdldCB8fCB0YXJnZXQsIGhhbmRsZXJBbmRTdGF0ZVswXSk7XG4gICAgICAgIGlmIChwcm94eUNhY2hlKSB7XG4gICAgICAgICAgICBwcm94eUNhY2hlLnNldCh0YXJnZXQsIGhhbmRsZXJBbmRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlckFuZFN0YXRlWzFdW0FGRkVDVEVEX1BST1BFUlRZXSA9IGFmZmVjdGVkO1xuICAgIGhhbmRsZXJBbmRTdGF0ZVsxXVtQUk9YWV9DQUNIRV9QUk9QRVJUWV0gPSBwcm94eUNhY2hlO1xuICAgIGhhbmRsZXJBbmRTdGF0ZVsxXVtUQVJHRVRfQ0FDSEVfUFJPUEVSVFldID0gdGFyZ2V0Q2FjaGU7XG4gICAgcmV0dXJuIGhhbmRsZXJBbmRTdGF0ZVsxXVtQUk9YWV9QUk9QRVJUWV07XG59O1xuY29uc3QgaXNBbGxPd25LZXlzQ2hhbmdlZCA9IChwcmV2T2JqLCBuZXh0T2JqKSA9PiB7XG4gICAgY29uc3QgcHJldktleXMgPSBSZWZsZWN0Lm93bktleXMocHJldk9iaik7XG4gICAgY29uc3QgbmV4dEtleXMgPSBSZWZsZWN0Lm93bktleXMobmV4dE9iaik7XG4gICAgcmV0dXJuIChwcmV2S2V5cy5sZW5ndGggIT09IG5leHRLZXlzLmxlbmd0aCB8fFxuICAgICAgICBwcmV2S2V5cy5zb21lKChrLCBpKSA9PiBrICE9PSBuZXh0S2V5c1tpXSkpO1xufTtcbi8qKlxuICogQ29tcGFyZSBjaGFuZ2VzIG9uIG9iamVjdHMuXG4gKlxuICogVGhpcyB3aWxsIGNvbXBhcmUgdGhlIGFmZmVjdGVkIHByb3BlcnRpZXMgb24gdHJhY2tlZCBvYmplY3RzIGluc2lkZSB0aGUgcHJveHlcbiAqIHRvIGNoZWNrIGlmIHRoZXJlIHdlcmUgYW55IGNoYW5nZXMgbWFkZSB0byBpdCxcbiAqIGJ5IGRlZmF1bHQgaWYgbm8gcHJvcGVydHkgd2FzIGFjY2Vzc2VkIG9uIHRoZSBwcm94eSBpdCB3aWxsIGF0dGVtcHQgdG8gZG8gYVxuICogcmVmZXJlbmNlIGVxdWFsaXR5IGNoZWNrIGZvciB0aGUgb2JqZWN0cyBwcm92aWRlZCAoT2JqZWN0LmlzKGEsIGIpKS4gSWYgeW91IGFjY2VzcyBhIHByb3BlcnR5XG4gKiBvbiB0aGUgcHJveHksIHRoZW4gaXNDaGFuZ2VkIHdpbGwgb25seSBjb21wYXJlIHRoZSBhZmZlY3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2T2JqIC0gVGhlIHByZXZpb3VzIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtvYmplY3R9IG5leHRPYmogLSBPYmplY3QgdG8gY29tcGFyZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gKiBAcGFyYW0ge1dlYWtNYXA8b2JqZWN0LCB1bmtub3duPn0gYWZmZWN0ZWQgLVxuICogV2Vha01hcCB0aGF0IGhvbGRzIHRoZSB0cmFja2luZyBvZiB3aGljaCBwcm9wZXJ0aWVzIGluIHRoZSBwcm94aWVkIG9iamVjdCB3ZXJlIGFjY2Vzc2VkLlxuICogQHBhcmFtIHtXZWFrTWFwPG9iamVjdCwgdW5rbm93bj59IFtjYWNoZV0gLVxuICogV2Vha01hcCB0aGF0IGhvbGRzIGEgY2FjaGUgb2YgdGhlIGNvbXBhcmlzb25zIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2Ugd2l0aCByZXBldGl0aXZlIGNvbXBhcmlzb25zLFxuICogYW5kIHRvIGF2b2lkIGluZmluaXRlIGxvb3Agd2l0aCBjaXJjdWxhciBzdHJ1Y3R1cmVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBhZmZlY3RlZCBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0IGhhcyBjaGFuZ2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBjcmVhdGVQcm94eSwgaXNDaGFuZ2VkIH0gZnJvbSAncHJveHktY29tcGFyZSc7XG4gKlxuICogY29uc3Qgb2JqID0geyBhOiBcIjFcIiwgYzogXCIyXCIsIGQ6IHsgZTogXCIzXCIgfSB9O1xuICogY29uc3QgYWZmZWN0ZWQgPSBuZXcgV2Vha01hcCgpO1xuICpcbiAqIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkob2JqLCBhZmZlY3RlZCk7XG4gKlxuICogcHJveHkuYVxuICpcbiAqIGlzQ2hhbmdlZChvYmosIHsgYTogXCIxXCIgfSwgYWZmZWN0ZWQpIC8vIGZhbHNlXG4gKlxuICogcHJveHkuYSA9IFwiMlwiXG4gKlxuICogaXNDaGFuZ2VkKG9iaiwgeyBhOiBcIjFcIiB9LCBhZmZlY3RlZCkgLy8gdHJ1ZVxuICovXG5leHBvcnQgY29uc3QgaXNDaGFuZ2VkID0gKHByZXZPYmosIG5leHRPYmosIGFmZmVjdGVkLCBjYWNoZSwgLy8gZm9yIG9iamVjdCB3aXRoIGN5Y2xlc1xuaXNFcXVhbCA9IE9iamVjdC5pcykgPT4ge1xuICAgIGlmIChpc0VxdWFsKHByZXZPYmosIG5leHRPYmopKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChwcmV2T2JqKSB8fCAhaXNPYmplY3QobmV4dE9iaikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHVzZWQgPSBhZmZlY3RlZC5nZXQoZ2V0T3JpZ2luYWxPYmplY3QocHJldk9iaikpO1xuICAgIGlmICghdXNlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlLmdldChwcmV2T2JqKTtcbiAgICAgICAgaWYgKGhpdCA9PT0gbmV4dE9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBvYmplY3Qgd2l0aCBjeWNsZXNcbiAgICAgICAgY2FjaGUuc2V0KHByZXZPYmosIG5leHRPYmopO1xuICAgIH1cbiAgICBsZXQgY2hhbmdlZCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZFtIQVNfS0VZX1BST1BFUlRZXSB8fCBbXSkge1xuICAgICAgICBjaGFuZ2VkID0gUmVmbGVjdC5oYXMocHJldk9iaiwga2V5KSAhPT0gUmVmbGVjdC5oYXMobmV4dE9iaiwga2V5KTtcbiAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgaWYgKHVzZWRbQUxMX09XTl9LRVlTX1BST1BFUlRZXSA9PT0gdHJ1ZSkge1xuICAgICAgICBjaGFuZ2VkID0gaXNBbGxPd25LZXlzQ2hhbmdlZChwcmV2T2JqLCBuZXh0T2JqKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZWRbSEFTX09XTl9LRVlfUFJPUEVSVFldIHx8IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNQcmV2ID0gISFSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcmV2T2JqLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEhUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dE9iaiwga2V5KTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSBoYXNQcmV2ICE9PSBoYXNOZXh0O1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZFtLRVlTX1BST1BFUlRZXSB8fCBbXSkge1xuICAgICAgICBjaGFuZ2VkID0gaXNDaGFuZ2VkKHByZXZPYmpba2V5XSwgbmV4dE9ialtrZXldLCBhZmZlY3RlZCwgY2FjaGUsIGlzRXF1YWwpO1xuICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVzZWQnKTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn07XG4vLyBleHBsaWNpdGx5IHRyYWNrIG9iamVjdCB3aXRoIG1lbW9cbmV4cG9ydCBjb25zdCB0cmFja01lbW8gPSAob2JqKSA9PiB7XG4gICAgaWYgKGlzT2JqZWN0VG9UcmFjayhvYmopKSB7XG4gICAgICAgIHJldHVybiBUUkFDS19NRU1PX1NZTUJPTCBpbiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFVud3JhcCBwcm94eSB0byBnZXQgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqXG4gKiBVc2VkIHRvIHJldHJpZXZlIHRoZSBvcmlnaW5hbCBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhlIHByb3h5IGluc3RhbmNlIHdpdGggYGNyZWF0ZVByb3h5YC5cbiAqXG4gKiBAcGFyYW0ge1Byb3h5PG9iamVjdD59IG9iaiAtICBUaGUgcHJveHkgd3JhcHBlciBvZiB0aGUgb3JpZ2luaWFsIG9iamVjdC5cbiAqIEByZXR1cm5zIHtvYmplY3QgfCBudWxsfSAtIFJldHVybiBlaXRoZXIgdGhlIHVud3JhcHBlZCBvYmplY3QgaWYgZXhpc3RzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBjcmVhdGVQcm94eSwgZ2V0VW50cmFja2VkIH0gZnJvbSAncHJveHktY29tcGFyZSc7XG4gKlxuICogY29uc3Qgb3JpZ2luYWwgPSB7IGE6IFwiMVwiLCBjOiBcIjJcIiwgZDogeyBlOiBcIjNcIiB9IH07XG4gKiBjb25zdCBhZmZlY3RlZCA9IG5ldyBXZWFrTWFwKCk7XG4gKlxuICogY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShvcmlnaW5hbCwgYWZmZWN0ZWQpO1xuICogY29uc3Qgb3JpZ2luYWxGcm9tUHJveHkgPSBnZXRVbnRyYWNrZWQocHJveHkpXG4gKlxuICogT2JqZWN0LmlzKG9yaWdpbmFsLCBvcmlnaW5hbEZyb21Qcm94eSkgLy8gdHJ1ZVxuICogaXNDaGFuZ2VkKG9yaWdpbmFsLCBvcmlnaW5hbEZyb21Qcm94eSwgYWZmZWN0ZWQpIC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVbnRyYWNrZWQgPSAob2JqKSA9PiB7XG4gICAgaWYgKGlzT2JqZWN0VG9UcmFjayhvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmpbR0VUX09SSUdJTkFMX1NZTUJPTF0gfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBNYXJrIG9iamVjdCB0byBiZSB0cmFja2VkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWFya3MgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBwYXNzZWQgaW50byBgY3JlYXRlUHJveHlgXG4gKiBhcyBtYXJrZWQgdG8gdHJhY2sgb3Igbm90LiBCeSBkZWZhdWx0IG9ubHkgQXJyYXkgYW5kIE9iamVjdCBhcmUgbWFya2VkIHRvIHRyYWNrLFxuICogc28gdGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gbWFyayBhIGNsYXNzIGluc3RhbmNlIHRvIHRyYWNrIG9yIHRvIG1hcmsgYSBvYmplY3RcbiAqIHRvIGJlIHVudHJhY2tlZCB3aGVuIGNyZWF0aW5nIHlvdXIgcHJveHkuXG4gKlxuICogQHBhcmFtIG9iaiAtIE9iamVjdCB0byBtYXJrIGFzIHRyYWNrZWQgb3Igbm90LlxuICogQHBhcmFtIG1hcmsgLSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB5b3Ugd2FudCB0byB0cmFjayB0aGlzIG9iamVjdCBvciBub3QuXG4gKiBAcmV0dXJucyAtIE5vIHJldHVybi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY3JlYXRlUHJveHksIG1hcmtUb1RyYWNrLCBpc0NoYW5nZWQgfSBmcm9tICdwcm94eS1jb21wYXJlJztcbiAqXG4gKiBjb25zdCBuZXN0ZWQgPSB7IGU6IFwiM1wiIH1cbiAqXG4gKiBtYXJrVG9UcmFjayhuZXN0ZWQsIGZhbHNlKVxuICpcbiAqIGNvbnN0IG9yaWdpbmFsID0geyBhOiBcIjFcIiwgYzogXCIyXCIsIGQ6IG5lc3RlZCB9O1xuICogY29uc3QgYWZmZWN0ZWQgPSBuZXcgV2Vha01hcCgpO1xuICpcbiAqIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkob3JpZ2luYWwsIGFmZmVjdGVkKTtcbiAqXG4gKiBwcm94eS5kLmVcbiAqXG4gKiBpc0NoYW5nZWQob3JpZ2luYWwsIHsgZDogeyBlOiBcIjNcIiB9IH0sIGFmZmVjdGVkKSAvLyB0cnVlXG4gKi9cbmV4cG9ydCBjb25zdCBtYXJrVG9UcmFjayA9IChvYmosIG1hcmsgPSB0cnVlKSA9PiB7XG4gICAgb2JqZWN0c1RvVHJhY2suc2V0KG9iaiwgbWFyayk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGBhZmZlY3RlZGAgdG8gcGF0aCBsaXN0XG4gKlxuICogYGFmZmVjdGVkYCBpcyBhIHdlYWsgbWFwIHdoaWNoIGlzIG5vdCBwcmludGFibGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbiBjb252ZXJ0IGl0IHRvIHByaW50YWJsZSBwYXRoIGxpc3QuXG4gKiBJdCdzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gQW4gb2JqZWN0IHRoYXQgaXMgdXNlZCB3aXRoIGBjcmVhdGVQcm94eWAuXG4gKiBAcGFyYW0gYWZmZWN0ZWQgLSBBIHdlYWsgbWFwIHRoYXQgaXMgdXNlZCB3aXRoIGBjcmVhdGVQcm94eWAuXG4gKiBAcGFyYW0gb25seVdpdGhWYWx1ZXMgLSBBbiBvcHRpb25hbCBib29sZWFuIHRvIGV4Y2x1ZGUgb2JqZWN0IGdldHRlcnMuXG4gKiBAcmV0dXJucyAtIEFuIGFycmF5IG9mIHBhdGhzLlxuICovXG5leHBvcnQgY29uc3QgYWZmZWN0ZWRUb1BhdGhMaXN0ID0gKG9iaiwgYWZmZWN0ZWQsIG9ubHlXaXRoVmFsdWVzKSA9PiB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHdhbGsgPSAoeCwgcGF0aCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHNlZW4uaGFzKHgpKSB7XG4gICAgICAgICAgICAvLyBmb3Igb2JqZWN0IHdpdGggY3ljbGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICBzZWVuLmFkZCh4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VkID0gaXNPYmplY3QoeCkgJiYgYWZmZWN0ZWQuZ2V0KGdldE9yaWdpbmFsT2JqZWN0KHgpKTtcbiAgICAgICAgaWYgKHVzZWQpIHtcbiAgICAgICAgICAgIChfYSA9IHVzZWRbSEFTX0tFWV9QUk9QRVJUWV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gYDpoYXMoJHtTdHJpbmcoa2V5KX0pYDtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gocGF0aCA/IFsuLi5wYXRoLCBzZWdtZW50XSA6IFtzZWdtZW50XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh1c2VkW0FMTF9PV05fS0VZU19QUk9QRVJUWV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gJzpvd25LZXlzJztcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gocGF0aCA/IFsuLi5wYXRoLCBzZWdtZW50XSA6IFtzZWdtZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoX2IgPSB1c2VkW0hBU19PV05fS0VZX1BST1BFUlRZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gYDpoYXNPd24oJHtTdHJpbmcoa2V5KX0pYDtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHBhdGggPyBbLi4ucGF0aCwgc2VnbWVudF0gOiBbc2VnbWVudF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9jID0gdXNlZFtLRVlTX1BST1BFUlRZXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb25seVdpdGhWYWx1ZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJyBpbiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih4LCBrZXkpIHx8IHt9KSkge1xuICAgICAgICAgICAgICAgICAgICB3YWxrKHhba2V5XSwgcGF0aCA/IFsuLi5wYXRoLCBrZXldIDogW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhvYmopO1xuICAgIHJldHVybiBsaXN0O1xufTtcbi8qKlxuICogcmVwbGFjZSBuZXdQcm94eSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIHVzZSBwcm94eS1wb2x5ZmlsbC5cbiAqIE5vdGUgdGhhdCBwcm94eS1wb2x5ZmlsbCBjYW4ndCBwb2x5ZmlsbCBldmVyeXRoaW5nLlxuICogVXNlIGl0IGF0IHlvdXIgb3duIHJpc2suXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlTmV3UHJveHkgPSAoZm4pID0+IHtcbiAgICBuZXdQcm94eSA9IGZuO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/proxy-compare/dist/index.js\n");

/***/ })

};
;